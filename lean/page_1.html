<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Generative Ontology — Step 1: Nothing ⇄ Everything</title>
  <style>
    :root{
      --bg:#0b0f14; --panel:#111823; --ink:#e8f0ff; --muted:#96b4d4; --accent:#66d9ef;
      --ok:#44d18d; --warn:#ffb454; --critical:#ff6b6b;
      --card:#0e1520; --stroke:#1b2736; --shadow:0 10px 30px rgba(0,0,0,.35);
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);font:14px/1.4 system-ui,Segoe UI,Inter,Roboto,Arial}
    .wrap{display:grid;grid-template-rows:auto 1fr auto;min-height:100vh}

    header{position:sticky;top:0;z-index:5;background:linear-gradient(180deg,rgba(11,15,20,.95),rgba(11,15,20,.85));backdrop-filter:blur(8px);border-bottom:1px solid var(--stroke)}
    .header-content{padding:1rem 1.5rem}
    h1{margin:0 0 .3rem 0;font-size:1.5rem;color:#e4edff;font-weight:600}
    .subtitle{color:var(--muted);font-size:.9rem;margin-bottom:1rem}

    .controls{display:flex;flex-wrap:wrap;gap:1rem;align-items:center}
    .control-group{display:flex;gap:.5rem;align-items:center;background:var(--panel);border:1px solid var(--stroke);padding:.5rem .8rem;border-radius:12px}
    label{color:var(--muted);font-size:.85rem;white-space:nowrap}
    [title]{cursor:help;border-bottom:1px dotted var(--stroke)}
    button{background:#0b131d;color:var(--ink);border:1px solid var(--stroke);padding:.5rem 1rem;border-radius:10px;font-size:.9rem;cursor:pointer;transition:all .2s}
    button:hover{border-color:var(--accent);background:rgba(102,217,239,.1)}
    button.primary{background:var(--accent);color:#000;border-color:var(--accent);font-weight:600}
    button.primary:hover{background:#7ae6ff}
    input[type="range"]{width:180px;accent-color:var(--accent)}

    main{display:grid;grid-template-columns:1fr 1fr;gap:1.5rem;padding:1.5rem;align-items:start}
    .panel{background:var(--panel);border:1px solid var(--stroke);border-radius:16px;box-shadow:var(--shadow);display:grid;grid-template-rows:auto 1fr auto;min-height:460px}
    .panel h2{margin:0;padding:1rem 1.2rem;border-bottom:1px solid var(--stroke);color:#c6d7f4;font-size:1.1rem;font-weight:600}
    .canvas-wrap{position:relative;min-height:360px}
    canvas{display:block;width:100%;height:100%}
    .caption{position:absolute;bottom:1rem;left:50%;transform:translateX(-50%);font-size:.85rem;color:var(--muted);background:rgba(11,15,20,.9);backdrop-filter:blur(8px);padding:.4rem .8rem;border-radius:8px;border:1px solid var(--stroke);text-align:center;max-width:90%;pointer-events:none}

    .syntax-overlay{position:absolute;top:1rem;right:1rem;background:rgba(14,21,32,.95);backdrop-filter:blur(10px);border:1px solid var(--stroke);border-radius:10px;padding:.8rem 1rem;min-width:220px;max-width:320px;font-family:ui-monospace,monospace;font-size:.85rem;box-shadow:0 4px 12px rgba(0,0,0,.4)}
    .syntax-overlay h4{margin:0 0 .6rem 0;color:var(--accent);font-size:.8rem;font-weight:600;text-transform:uppercase;letter-spacing:.5px}
    .syntax-row{margin:.4rem 0;display:flex;align-items:center;gap:.6rem}
    .syntax-label{color:var(--muted);min-width:50px;font-size:.75rem}
    .syntax-value{color:var(--ink);background:rgba(0,0,0,.3);padding:.2rem .5rem;border-radius:5px;flex:1;border:1px solid rgba(102,217,239,.2)}

    .status-bar{display:flex;gap:1.5rem;align-items:center;justify-content:center;padding:1rem;border-top:1px solid var(--stroke);flex-wrap:wrap}
    .status-item{display:flex;align-items:center;gap:.5rem;font-size:.85rem}
    .status-label{color:var(--muted)}
    .status-value{color:var(--ink);font-family:ui-monospace,monospace;background:rgba(11,15,20,.5);padding:.25rem .5rem;border-radius:6px;min-width:60px;text-align:center}
    .status-indicator{display:inline-block;width:8px;height:8px;border-radius:50%;background:var(--muted)}
    .status-indicator.active{background:var(--ok);box-shadow:0 0 8px var(--ok)}
    .status-indicator.collapsed{background:var(--critical);box-shadow:0 0 8px var(--critical)}

    .explanation{padding:0 1.5rem 1.5rem;display:grid;grid-template-columns:1fr 1fr;gap:1.5rem}
    .exp-card{background:var(--card);border:1px solid var(--stroke);border-radius:14px;padding:1rem 1.2rem;overflow:visible}
    .exp-card h3{margin:0 0 .6rem 0;color:#e4edff;font-size:.9rem;font-weight:600}
    .exp-card p{margin:.3rem 0;line-height:1.5;color:var(--muted);font-size:.8rem}
    .exp-card strong{color:var(--ink)}
    .exp-card code{font-family:ui-monospace,monospace;background:rgba(102,217,239,.1);padding:.1rem .3rem;border-radius:4px;color:var(--accent);font-size:.75rem;white-space:normal;word-break:break-word}

    footer{padding:.8rem 1.5rem;color:var(--muted);border-top:1px solid var(--stroke);text-align:center;font-size:.85rem}
    .kbd{border:1px solid var(--stroke);background:#0b121b;border-radius:6px;padding:.1rem .4rem;color:#a5c2ff;font-family:ui-monospace,monospace}

    @media (max-width: 1100px){
      main{grid-template-columns:1fr}
      .explanation{grid-template-columns:1fr}
    }
  </style>
</head>
<body>
<div class="wrap">
  <header>
    <div class="header-content">
      <h1>Generative Ontology — Step 1: Nothing ⇄ Everything</h1>
      <p class="subtitle">The Plenum (unmarked state) and the first oscillation via Re-entry Nucleus R</p>

      <div class="controls">
        <div class="control-group">
          <label for="R" title="Re-entry nucleus strength controls color spectrum: Low R = infrared/red (classical), High R = violet/white (constructive)">R (nucleus)</label>
          <input type="range" id="R" min="0" max="100" step="1" value="50"/>
          <span id="RValue">0.50</span>
        </div>

        <div class="control-group">
          <label for="nodes" title="Node count: 1 (Nothing) to ∞ (Infinite Nothing) - controls graph complexity">Nodes</label>
          <input type="range" id="nodes" min="1" max="64" step="1" value="16"/>
          <span id="nodesValue">16</span>
        </div>

        <div class="control-group">
          <button id="btnCollapse" class="primary" title="Toggle between Nothing (plenum) and Everything (fully marked singularity)">
            Collapse ⇄ Expand
          </button>
        </div>

        <div class="control-group">
          <button id="btnOscillate" title="Trigger re-entry oscillation in local observer">
            Create Mark ¬(·)
          </button>
        </div>

        <div class="control-group">
          <button id="btnReset">Reset</button>
        </div>
      </div>
    </div>
  </header>

  <main>
    <!-- GLOBAL: Nothing ⇄ Everything -->
    <section class="panel">
      <h2>Global — The Plenum (Nothing ⇄ Everything)</h2>
      <div class="canvas-wrap">
        <canvas id="globalCanvas"></canvas>
        <div class="caption" id="globalCaption">Unmarked Nothing (plenum — latent potential)</div>
        <div class="syntax-overlay" id="globalSyntaxOverlay">
          <h4>Plenum State</h4>
          <div class="syntax-row">
            <span class="syntax-label">LoF:</span>
            <span class="syntax-value" id="globalLoF">⊙</span>
          </div>
          <div class="syntax-row">
            <span class="syntax-label">Logic:</span>
            <span class="syntax-value" id="globalLogic">Unmarked</span>
          </div>
          <div class="syntax-row">
            <span class="syntax-label">Nodes:</span>
            <span class="syntax-value" id="globalNodes">16</span>
          </div>
          <div class="syntax-row">
            <span class="syntax-label">State:</span>
            <span class="syntax-value" id="globalStateOverlay">Plenum</span>
          </div>
        </div>
      </div>
      <div class="status-bar">
        <div class="status-item">
          <span class="status-indicator" id="plenumIndicator"></span>
          <span class="status-label">State:</span>
          <span class="status-value" id="globalState">Plenum</span>
        </div>
        <div class="status-item">
          <span class="status-label">Distinctions:</span>
          <span class="status-value" id="distinctionCount">∞ (latent)</span>
        </div>
      </div>
    </section>

    <!-- LOCAL: First Oscillation via Re-entry -->
    <section class="panel">
      <h2>Local — First Oscillation (Re-entry through R)</h2>
      <div class="canvas-wrap">
        <canvas id="localCanvas"></canvas>
        <div class="caption" id="localCaption">Awaiting re-entry...</div>
        <div class="syntax-overlay" id="syntaxOverlay">
          <h4>Representations</h4>
          <div class="syntax-row">
            <span class="syntax-label">LoF:</span>
            <span class="syntax-value" id="lofSyntax">⟨ ⟩</span>
          </div>
          <div class="syntax-row">
            <span class="syntax-label">Logic:</span>
            <span class="syntax-value" id="logicSyntax">⊥</span>
          </div>
          <div class="syntax-row">
            <span class="syntax-label">Nucleus:</span>
            <span class="syntax-value" id="nucleusSyntax">R(·) = ·</span>
          </div>
          <div class="syntax-row">
            <span class="syntax-label">Euler:</span>
            <span class="syntax-value" id="eulerSyntax">e^(i·0) = 1</span>
          </div>
        </div>
      </div>
      <div class="status-bar">
        <div class="status-item">
          <span class="status-indicator" id="oscillatorIndicator"></span>
          <span class="status-label">Oscillator:</span>
          <span class="status-value" id="oscillatorState">Inactive</span>
        </div>
        <div class="status-item">
          <span class="status-label">R-fixed:</span>
          <span class="status-value" id="rfixedStatus">—</span>
        </div>
      </div>
    </section>
  </main>

  <div class="explanation">
    <div class="exp-card">
      <h3>1. The Plenum (Global) — 0D Point ⇄ Circle</h3>
      <p><strong>Nothing ≡ Everything</strong> at the unmarked state. The plenum is <strong>undifferentiated potential</strong> — all possible distinctions latent but not yet actualized.</p>
      <p><strong>Generative ontology</strong>: At the most basic level, this is the transition from a <strong>0D point</strong> (singularity, collapsed) to a <strong>circle</strong> (expanded, all nodes). From another perspective, a <strong>line rotating</strong> traces out the circle — showing how 1D generates 2D through continuous transformation.</p>
      <p><strong>Infrared locked</strong>: The plenum is shown in <strong>infrared/dark red</strong> because the <strong>R nucleus has not been applied yet</strong>. This is the pre-logical, unmarked state before re-entry begins. The R value slider controls the Local panel's spectrum but does not affect the Global plenum.</p>
      <p><strong>Node count</strong>: From <code>1</code> (Nothing) to <code>∞</code> (Infinite Nothing, shown as 64 nodes), the fully connected graph shows all latent distinctions. The <strong>radiance</strong> emerges from overlapping translucent edges.</p>
      <p>The <strong>Collapse ⇄ Expand</strong> button demonstrates the fundamental dynamic: point → circle → point in smooth animation.</p>
    </div>

    <div class="exp-card">
      <h3>2. Re-entry as Crossing Creates Boundary (Local)</h3>
      <p><strong>Two opposing lines</strong> (blue ← → purple) traveling toward each other represent the <strong>re-entry operator R</strong>. <strong>Cosine</strong> and <strong>sine waves</strong> flow through them, meeting at the center to create the collapse.</p>
      <p>When they <strong>cross/collapse together</strong>, they create:</p>
      <p>• <strong>The Mark ¬(·)</strong> — Spencer-Brown's first distinction<br/>
         • <strong>The Circle</strong> — Euler Boundary emerging from the crossing<br/>
         • <strong>The Plenum emerges</strong> — As arrows converge, the Global plenum (infrared graph) replicates in the center<br/>
         • <strong>Oscillation</strong> — Between marked (lines meet) and unmarked (lines separate)</p>
      <p><strong>Convergence reveals structure</strong>: As the arrows collapse together (markedness > 0.3), the fully connected graph from the Global panel <strong>emerges at the center</strong>, showing how re-entry brings the unmarked plenum into manifestation. This visually demonstrates that <strong>the collapse creates the boundary that contains the plenum</strong>.</p>
      <p><strong>Spectrum progression</strong>: The <strong>R nucleus slider</strong> controls the spectral color from <strong>infrared</strong> (low R, classical) → <strong>red</strong> → <strong>orange</strong> → <strong>yellow</strong> → <strong>green</strong> → <strong>cyan</strong> → <strong>blue</strong> → <strong>violet</strong> → <strong>white/UV</strong> (high R, constructive). The boundary circle, Euler lines, and collision point all use this spectrum.</p>
      <p><strong>Mathematical soundness</strong>: The crossing is the <strong>calling</strong> operation in LoF. The circle is the <strong>Euler Boundary ∂○</strong> — the minimal nontrivial fixed point where <code>R(a) = a</code>, verified in Lean.</p>
    </div>
  </div>

  <footer>
    <span class="muted">Keyboard shortcuts:</span>
    <span class="kbd">C</span> collapse/expand •
    <span class="kbd">M</span> create mark •
    <span class="kbd">R</span> reset •
    <span class="muted">v2.5-convergence</span>
  </footer>
</div>

<script>
(function(){
  const dpr = Math.min(window.devicePixelRatio || 1, 2);
  const $ = (id) => document.getElementById(id);

  // State
  const state = {
    R: 0.50,                    // Re-entry nucleus strength (0-1, controls color spectrum)
    nodes: 16,                  // Node count (1 to 64)
    collapsed: false,           // Global collapse state
    collapseProgress: 0,        // Collapse animation progress (0 = expanded, 1 = collapsed)
    collapseTarget: 0,          // Target collapse progress
    oscillating: false,         // Local oscillator active
    oscillatorPhase: 0,         // Current phase of oscillation
    oscillatorSpeed: 0.002,     // Speed of oscillation
  };

  // Spectrum color calculation: R value maps to wavelength spectrum
  // Low R (0) = Red/Infrared (near black) -> High R (1) = Violet/White
  function getSpectrumColor(R, alpha = 1) {
    // R: 0.0-0.2 = Infrared (dark red to red)
    // R: 0.2-0.4 = Red to Orange to Yellow
    // R: 0.4-0.6 = Yellow to Green to Cyan
    // R: 0.6-0.8 = Cyan to Blue to Violet
    // R: 0.8-1.0 = Violet to White (UV)

    let r, g, b;

    if (R < 0.2) {
      // Infrared: dark red fading from near-black
      const t = R / 0.2;
      r = 20 + 200 * t;
      g = 0;
      b = 0;
    } else if (R < 0.4) {
      // Red to Orange to Yellow
      const t = (R - 0.2) / 0.2;
      r = 255;
      g = 165 * t;
      b = 0;
    } else if (R < 0.6) {
      // Yellow to Green to Cyan
      const t = (R - 0.4) / 0.2;
      r = 255 * (1 - t);
      g = 255;
      b = 255 * t;
    } else if (R < 0.8) {
      // Cyan to Blue to Violet
      const t = (R - 0.6) / 0.2;
      r = 138 * t;
      g = 255 * (1 - t);
      b = 255;
    } else {
      // Violet to White (UV)
      const t = (R - 0.8) / 0.2;
      r = 138 + (255 - 138) * t;
      g = 0 + 255 * t;
      b = 255;
    }

    return `rgba(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b)}, ${alpha})`;
  }

  function getSpectrumName(R) {
    if (R < 0.2) return 'Infrared (Dark Red)';
    if (R < 0.35) return 'Red';
    if (R < 0.45) return 'Orange';
    if (R < 0.55) return 'Yellow-Green';
    if (R < 0.65) return 'Cyan';
    if (R < 0.75) return 'Blue';
    if (R < 0.85) return 'Violet';
    return 'UV (White)';
  }

  // UI elements
  const RSlider = $('R');
  const RValue = $('RValue');
  const nodesSlider = $('nodes');
  const nodesValue = $('nodesValue');
  const btnCollapse = $('btnCollapse');
  const btnOscillate = $('btnOscillate');
  const btnReset = $('btnReset');

  const globalCanvas = $('globalCanvas');
  const localCanvas = $('localCanvas');
  const gctx = globalCanvas.getContext('2d');
  const lctx = localCanvas.getContext('2d');

  const globalCaption = $('globalCaption');
  const localCaption = $('localCaption');
  const globalState = $('globalState');
  const oscillatorState = $('oscillatorState');
  const distinctionCount = $('distinctionCount');
  const rfixedStatus = $('rfixedStatus');
  const plenumIndicator = $('plenumIndicator');
  const oscillatorIndicator = $('oscillatorIndicator');

  // Global syntax overlay elements
  const globalLoF = $('globalLoF');
  const globalLogic = $('globalLogic');
  const globalNodes = $('globalNodes');
  const globalStateOverlay = $('globalStateOverlay');

  // Local syntax overlay elements
  const lofSyntax = $('lofSyntax');
  const logicSyntax = $('logicSyntax');
  const nucleusSyntax = $('nucleusSyntax');
  const eulerSyntax = $('eulerSyntax');

  // Canvas resize
  function resize(){
    for (const c of [globalCanvas, localCanvas]){
      const rect = c.parentElement.getBoundingClientRect();
      c.width = Math.max(300, rect.width * dpr);
      c.height = Math.max(320, rect.height * dpr);
    }
  }
  new ResizeObserver(resize).observe(document.body);
  resize();

  // === GLOBAL PANEL: Plenum ⇄ Collapse ===
  function drawGlobal(){
    const W = globalCanvas.width, H = globalCanvas.height;
    const cx = W/2, cy = H/2;

    gctx.setTransform(1,0,0,1,0,0);
    gctx.clearRect(0,0,W,H);

    // Background - will be computed from edge density below
    const bgGrd = gctx.createRadialGradient(cx, cy, 0, cx, cy, Math.min(W,H)*0.5);
    bgGrd.addColorStop(0, '#0a1019');
    bgGrd.addColorStop(1, '#070b12');
    gctx.fillStyle = bgGrd;
    gctx.fillRect(0,0,W,H);

    // Determine if we should draw the collapsed graph
    const showCollapsed = state.collapseProgress > 0.01;

    if (showCollapsed) {
      // COLLAPSED STATE (Everything = fully marked singularity)
      const numNodes = state.nodes;
      // Use circular radius (based on minimum dimension to ensure circle not oval)
      const baseRadius = Math.min(W, H) * 0.35;
      // Animate collapse: full radius when expanded (progress=0), tiny when collapsed (progress=1)
      const graphRadius = baseRadius * (1 - state.collapseProgress * 0.95); // Shrinks to 5% of original
      const nodes = [];
      const edges = [];
      const time = performance.now() * 0.0005;

      // Create nodes in a perfect circle
      for(let i=0; i<numNodes; i++){
        const angle = (i/numNodes) * Math.PI * 2 + time * 0.3;
        const spiral = 1 - (Math.sin(time + i*0.2) * 0.08); // Subtle pulsing
        const r = graphRadius * spiral;
        nodes.push({
          x: cx + Math.cos(angle) * r,
          y: cy + Math.sin(angle) * r
        });
      }

      // Collect all edges for density computation
      for(let i=0; i<numNodes; i++){
        for(let j=i+1; j<numNodes; j++){
          edges.push({ n1: nodes[i], n2: nodes[j] });
        }
      }

      // Draw all edges (fully connected) with RADIANT glow effect
      // Draw edges multiple times with decreasing width and increasing blur for glow
      // LOCKED TO INFRARED - R nucleus has not been applied to plenum yet
      const edgePasses = [
        { width: 8, alpha: 0.02 },  // Outermost glow (widest, faintest)
        { width: 5, alpha: 0.04 },  // Mid glow
        { width: 3, alpha: 0.06 },  // Inner glow
        { width: 1.5, alpha: 0.12 }, // Edge itself
      ];

      for(const pass of edgePasses){
        gctx.globalAlpha = pass.alpha;
        for(const edge of edges){
          const n1 = edge.n1, n2 = edge.n2;
          const centerDist = Math.hypot((n1.x+n2.x)/2-cx, (n1.y+n2.y)/2-cy);
          const maxCenterDist = graphRadius || 1;

          // INFRARED COLOR (locked, R value = 0.1 for dark red)
          const distFactor = 1 - Math.min(1, centerDist/maxCenterDist);
          const edgeR = Math.max(0, 0.1 - 0.08 * (1 - distFactor)); // Darker near center, infrared range

          gctx.strokeStyle = getSpectrumColor(edgeR, 1);
          gctx.lineWidth = pass.width * dpr;
          gctx.beginPath();
          gctx.moveTo(n1.x, n1.y);
          gctx.lineTo(n2.x, n2.y);
          gctx.stroke();
        }
      }
      gctx.globalAlpha = 1;

      // Draw nodes (larger and more visible) - INFRARED LOCKED
      gctx.globalAlpha = 0.7;
      for(const node of nodes){
        const centerDist = Math.hypot(node.x-cx, node.y-cy);
        const maxCenterDist = graphRadius || 1;
        const distRatio = centerDist / maxCenterDist;
        const baseSize = 3 * dpr;
        const size = baseSize + (1 - distRatio) * 6 * dpr; // Bigger nodes near center
        const nodeR = 0.1 * distRatio; // INFRARED (0.1 range)
        gctx.fillStyle = getSpectrumColor(nodeR, 0.9);
        gctx.beginPath();
        gctx.arc(node.x, node.y, size, 0, Math.PI*2);
        gctx.fill();

        // Node glow
        gctx.fillStyle = getSpectrumColor(nodeR, 0.3);
        gctx.beginPath();
        gctx.arc(node.x, node.y, size * 2, 0, Math.PI*2);
        gctx.fill();
      }
      gctx.globalAlpha = 1;

      // Central singularity (black hole) - grows with collapse progress - INFRARED LOCKED
      const singularitySize = state.collapseProgress * (30*dpr + 10*dpr*Math.sin(time*2));
      if (singularitySize > 5*dpr) {
        const sGrd = gctx.createRadialGradient(cx,cy,0, cx,cy,singularitySize);
        sGrd.addColorStop(0, '#000000');
        sGrd.addColorStop(0.4, getSpectrumColor(0.03, 0.5 * state.collapseProgress)); // INFRARED
        sGrd.addColorStop(0.7, getSpectrumColor(0.1, 0.8 * state.collapseProgress));  // INFRARED
        sGrd.addColorStop(1, getSpectrumColor(0.1, 0));
        gctx.globalAlpha = 0.5 * state.collapseProgress; // Opacity grows with collapse
        gctx.fillStyle = sGrd;
        gctx.fillRect(0,0,W,H);
        gctx.globalAlpha = 1;

        // Event horizon ring - INFRARED
        gctx.strokeStyle = getSpectrumColor(0.1, 0.7 * state.collapseProgress);
        gctx.lineWidth = 2*dpr;
        gctx.beginPath();
        gctx.arc(cx, cy, singularitySize*0.7, 0, Math.PI*2);
        gctx.stroke();
      }

      // Update status based on collapse progress
      if (state.collapseProgress > 0.8) {
        globalCaption.textContent = 'Everything (fully marked — singularity)';
        globalState.textContent = 'Collapsed';
        distinctionCount.textContent = '1 (merged)';
        plenumIndicator.className = 'status-indicator collapsed';
        globalStateOverlay.textContent = 'Collapsed';
        globalLoF.textContent = '●';  // Dot (marked singularity)
        globalLogic.textContent = 'Marked';
      } else if (state.collapseProgress > 0.01) {
        globalCaption.textContent = `Collapsing... (${(state.collapseProgress*100).toFixed(0)}%)`;
        globalState.textContent = 'Collapsing';
        distinctionCount.textContent = `${numNodes} → 1`;
        plenumIndicator.className = 'status-indicator';
        globalStateOverlay.textContent = 'Collapsing';
        globalLoF.textContent = '⊙ → ●';
        globalLogic.textContent = 'Collapsing';
      } else {
        globalLoF.textContent = '⊙';  // Circle with dot (unmarked plenum)
        globalLogic.textContent = 'Unmarked';
      }

      // Update global syntax overlay
      globalNodes.textContent = state.nodes;

    } else {
      // PLENUM STATE (Nothing = unmarked potential) - already drew background above

      // Latent field (potential but not actualized)
      const fieldDensity = 120;
      gctx.globalAlpha = 0.15;
      for(let i=0; i<fieldDensity; i++){
        const x = Math.random() * W;
        const y = Math.random() * H;
        const size = (0.5 + Math.random()*1.5) * dpr;
        gctx.fillStyle = `hsl(${200 + Math.random()*40}, 70%, ${60 + Math.random()*20}%)`;
        gctx.beginPath();
        gctx.arc(x, y, size, 0, Math.PI*2);
        gctx.fill();
      }
      gctx.globalAlpha = 1;

      // Potential connections (faint, latent)
      gctx.globalAlpha = 0.08;
      gctx.strokeStyle = '#6ea8ff';
      gctx.lineWidth = 0.5*dpr;
      const numPotential = 30;
      for(let i=0; i<numPotential; i++){
        const x1 = cx + (Math.random()-0.5) * W*0.6;
        const y1 = cy + (Math.random()-0.5) * H*0.6;
        const x2 = cx + (Math.random()-0.5) * W*0.6;
        const y2 = cy + (Math.random()-0.5) * H*0.6;
        gctx.beginPath();
        gctx.moveTo(x1,y1);
        gctx.lineTo(x2,y2);
        gctx.stroke();
      }
      gctx.globalAlpha = 1;

      globalCaption.textContent = 'Unmarked Nothing (plenum — latent potential)';
      globalState.textContent = 'Plenum';
      distinctionCount.textContent = '∞ (latent)';
      plenumIndicator.className = 'status-indicator active';

      // Update global syntax overlay
      globalLoF.textContent = '⊙';  // Circle with dot
      globalLogic.textContent = 'Unmarked';
      globalNodes.textContent = `${state.nodes} (latent)`;
      globalStateOverlay.textContent = 'Plenum';
    }
  }

  // === LOCAL PANEL: First Oscillation via Re-entry ===
  function drawLocal(){
    const W = localCanvas.width, H = localCanvas.height;
    const cx = W/2, cy = H/2;

    lctx.setTransform(1,0,0,1,0,0);
    lctx.clearRect(0,0,W,H);

    // Background - will add computed radiance if oscillating
    const bgGrd = lctx.createRadialGradient(cx, cy, 0, cx, cy, Math.min(W,H)*0.5);
    bgGrd.addColorStop(0, '#0b121b');
    bgGrd.addColorStop(1, '#081018');
    lctx.fillStyle = bgGrd;
    lctx.fillRect(0,0,W,H);

    if (state.oscillating) {
      // OSCILLATOR ACTIVE: Show two opposing lines creating re-entry (the crossing)

      const radius = Math.min(W,H) * 0.25;
      const phase = state.oscillatorPhase;

      // Phase oscillates: 0 (unmarked) → π (marked) → 2π (unmarked)
      const markedness = (Math.sin(phase) + 1) / 2; // 0 to 1

      // TWO OPPOSING LINES traveling toward each other (re-entry as crossing)
      const lineLength = radius * 1.4;
      const separation = radius * (1 - markedness); // They collapse together as markedness increases

      // Line 1: Traveling from left (with COSINE wave flowing through it)
      const x1Start = cx - lineLength - separation;
      const x1End = cx - separation;

      // Draw cosine wave flowing along line 1
      const waveAmp = 12 * dpr * markedness; // Wave amplitude grows with markedness
      const waveFreq = 3; // Number of wave cycles
      lctx.strokeStyle = `rgba(102, 217, 239, ${0.6 + markedness*0.4})`;
      lctx.lineWidth = 2*dpr;
      lctx.beginPath();
      const lineLen1 = x1End - x1Start;
      for(let i=0; i<=50; i++){
        const t = i/50;
        const x = x1Start + t * lineLen1;
        const waveOffset = Math.cos(t * Math.PI * 2 * waveFreq + phase * 2) * waveAmp;
        if(i===0) lctx.moveTo(x, cy + waveOffset);
        else lctx.lineTo(x, cy + waveOffset);
      }
      lctx.stroke();

      // Base line 1 (faint reference)
      lctx.strokeStyle = `rgba(102, 217, 239, ${0.2})`;
      lctx.lineWidth = 1*dpr;
      lctx.beginPath();
      lctx.moveTo(x1Start, cy);
      lctx.lineTo(x1End, cy);
      lctx.stroke();

      // Arrow on line 1 (pointing right →)
      lctx.fillStyle = `rgba(102, 217, 239, ${0.7 + markedness*0.3})`;
      lctx.beginPath();
      lctx.moveTo(x1End, cy);
      lctx.lineTo(x1End - 8*dpr, cy - 5*dpr);
      lctx.lineTo(x1End - 8*dpr, cy + 5*dpr);
      lctx.closePath();
      lctx.fill();

      // Line 2: Traveling from right (with SINE wave flowing through it)
      const x2Start = cx + lineLength + separation;
      const x2End = cx + separation;

      // Draw sine wave flowing along line 2
      lctx.strokeStyle = `rgba(200, 140, 255, ${0.6 + markedness*0.4})`;
      lctx.lineWidth = 2*dpr;
      lctx.beginPath();
      const lineLen2 = x2Start - x2End;
      for(let i=0; i<=50; i++){
        const t = i/50;
        const x = x2Start - t * lineLen2;
        const waveOffset = Math.sin(t * Math.PI * 2 * waveFreq - phase * 2) * waveAmp;
        if(i===0) lctx.moveTo(x, cy + waveOffset);
        else lctx.lineTo(x, cy + waveOffset);
      }
      lctx.stroke();

      // Base line 2 (faint reference)
      lctx.strokeStyle = `rgba(200, 140, 255, ${0.2})`;
      lctx.lineWidth = 1*dpr;
      lctx.beginPath();
      lctx.moveTo(x2Start, cy);
      lctx.lineTo(x2End, cy);
      lctx.stroke();

      // Arrow on line 2 (pointing left ←)
      lctx.fillStyle = `rgba(200, 140, 255, ${0.7 + markedness*0.3})`;
      lctx.beginPath();
      lctx.moveTo(x2End, cy);
      lctx.lineTo(x2End + 8*dpr, cy - 5*dpr);
      lctx.lineTo(x2End + 8*dpr, cy + 5*dpr);
      lctx.closePath();
      lctx.fill();

      // The CIRCLE emerges from the crossing/collision (re-entry creates boundary)
      // Draw with RADIANT glow effect (multiple passes)
      const circleAlpha = markedness; // Circle appears as lines meet
      if (circleAlpha > 0.05) {
        const circlePasses = [
          { width: 12, alpha: 0.08 * circleAlpha },  // Outermost glow
          { width: 8, alpha: 0.12 * circleAlpha },   // Mid glow
          { width: 5, alpha: 0.2 * circleAlpha },    // Inner glow
          { width: 2 + markedness*4, alpha: 0.6 * circleAlpha }, // Circle itself
        ];

        for(const pass of circlePasses){
          lctx.globalAlpha = pass.alpha;
          lctx.strokeStyle = getSpectrumColor(state.R, 1);
          lctx.lineWidth = pass.width * dpr;
          lctx.beginPath();
          lctx.arc(cx, cy, radius, 0, Math.PI*2);
          lctx.stroke();
        }
        lctx.globalAlpha = 1;
      }

      // EULER CIRCLE: Counter-rotating radius lines (e^(iθ) visualization)
      // Both lines use DARK ORANGE (base spectrum), brighten when they meet
      const angle1 = phase;
      const angle2 = -phase;
      const ex1 = cx + Math.cos(angle1) * radius;
      const ey1 = cy + Math.sin(angle1) * radius;
      const ex2 = cx + Math.cos(angle2) * radius;
      const ey2 = cy + Math.sin(angle2) * radius;

      // Calculate if lines are meeting (aligned)
      const angleDiff = Math.abs(Math.cos(angle1) - Math.cos(angle2));
      const linesMeeting = angleDiff < 0.3; // Lines are close to meeting
      const eulerBaseR = Math.max(0.25, state.R * 0.5); // Dark orange base
      const eulerBrightR = Math.min(0.5, state.R * 0.8); // Brighter orange when meeting
      const eulerR = linesMeeting ? eulerBrightR : eulerBaseR;
      const eulerAlpha = 0.6 + (linesMeeting ? 0.4 : 0);

      // Glow passes for Euler lines (SAME COLOR for both)
      const eulerGlow = [
        { width: 8, alpha: 0.08 * eulerAlpha },
        { width: 5, alpha: 0.12 * eulerAlpha },
        { width: 2, alpha: eulerAlpha }
      ];

      // Line 1: Rotating clockwise
      for(const pass of eulerGlow){
        lctx.globalAlpha = pass.alpha;
        lctx.strokeStyle = getSpectrumColor(eulerR, 1);
        lctx.lineWidth = pass.width * dpr;
        lctx.beginPath();
        lctx.moveTo(cx, cy);
        lctx.lineTo(ex1, ey1);
        lctx.stroke();
      }
      lctx.globalAlpha = 1;

      // Line 2: Counter-rotating (SAME COLOR)
      for(const pass of eulerGlow){
        lctx.globalAlpha = pass.alpha;
        lctx.strokeStyle = getSpectrumColor(eulerR, 1);
        lctx.lineWidth = pass.width * dpr;
        lctx.beginPath();
        lctx.moveTo(cx, cy);
        lctx.lineTo(ex2, ey2);
        lctx.stroke();
      }
      lctx.globalAlpha = 1;

      // When lines are fully extended (pointing opposite directions), draw dark circles at endpoints
      const fullyExtended = Math.abs(Math.abs(angleDiff) - 2) < 0.3; // Lines pointing opposite
      if (fullyExtended) {
        const endpointR = eulerBaseR; // Dark orange
        const endpointSize = 8 * dpr;

        // Circle at endpoint 1
        lctx.globalAlpha = 0.7;
        lctx.fillStyle = getSpectrumColor(endpointR, 0.6);
        lctx.beginPath();
        lctx.arc(ex1, ey1, endpointSize, 0, Math.PI*2);
        lctx.fill();

        // Circle at endpoint 2
        lctx.fillStyle = getSpectrumColor(endpointR, 0.6);
        lctx.beginPath();
        lctx.arc(ex2, ey2, endpointSize, 0, Math.PI*2);
        lctx.fill();
        lctx.globalAlpha = 1;
      }

      // EULER COMPONENTS: cos(θ) and sin(θ) projections
      // Cosine (horizontal projection from rotating line)
      const cosProjection = Math.cos(angle1) * radius;
      lctx.strokeStyle = `rgba(102, 217, 239, ${0.5 + markedness*0.3})`;
      lctx.lineWidth = 1.5*dpr;
      lctx.setLineDash([3*dpr, 3*dpr]);
      lctx.beginPath();
      lctx.moveTo(cx, cy);
      lctx.lineTo(cx + cosProjection, cy);
      lctx.stroke();

      // Sine (vertical projection from rotating line)
      const sinProjection = Math.sin(angle1) * radius;
      lctx.strokeStyle = `rgba(200, 140, 255, ${0.5 + markedness*0.3})`;
      lctx.lineWidth = 1.5*dpr;
      lctx.beginPath();
      lctx.moveTo(cx + cosProjection, cy);
      lctx.lineTo(ex1, ey1);
      lctx.stroke();
      lctx.setLineDash([]);

      // REPLICATE GLOBAL PLENUM in the center as arrows converge
      if (markedness > 0.3) {
        const plenumScale = markedness; // Grows from 0.3 to 1.0
        const plenumRadius = radius * 0.4 * plenumScale; // Smaller than main circle
        const numPlenumNodes = state.nodes;
        const plenumNodes = [];
        const plenumTime = performance.now() * 0.0005;

        // Create nodes in circle (same as Global)
        for(let i=0; i<numPlenumNodes; i++){
          const angle = (i/numPlenumNodes) * Math.PI * 2 + plenumTime * 0.3;
          const spiral = 1 - (Math.sin(plenumTime + i*0.2) * 0.08);
          const r = plenumRadius * spiral;
          plenumNodes.push({
            x: cx + Math.cos(angle) * r,
            y: cy + Math.sin(angle) * r
          });
        }

        // Draw all edges (fully connected) - INFRARED like Global
        const edgePasses = [
          { width: 4, alpha: 0.015 * plenumScale },
          { width: 2.5, alpha: 0.03 * plenumScale },
          { width: 1.5, alpha: 0.045 * plenumScale },
          { width: 0.8, alpha: 0.08 * plenumScale }
        ];

        for(const pass of edgePasses){
          lctx.globalAlpha = pass.alpha;
          for(let i=0; i<numPlenumNodes; i++){
            for(let j=i+1; j<numPlenumNodes; j++){
              const n1 = plenumNodes[i], n2 = plenumNodes[j];
              const centerDist = Math.hypot((n1.x+n2.x)/2-cx, (n1.y+n2.y)/2-cy);
              const distFactor = 1 - Math.min(1, centerDist/plenumRadius);
              const edgeR = Math.max(0, 0.1 - 0.08 * (1 - distFactor)); // INFRARED

              lctx.strokeStyle = getSpectrumColor(edgeR, 1);
              lctx.lineWidth = pass.width * dpr;
              lctx.beginPath();
              lctx.moveTo(n1.x, n1.y);
              lctx.lineTo(n2.x, n2.y);
              lctx.stroke();
            }
          }
        }
        lctx.globalAlpha = 1;

        // Draw nodes - INFRARED
        lctx.globalAlpha = 0.5 * plenumScale;
        for(const node of plenumNodes){
          const centerDist = Math.hypot(node.x-cx, node.y-cy);
          const distRatio = plenumRadius > 0 ? centerDist / plenumRadius : 0;
          const baseSize = 1.5 * dpr;
          const size = baseSize + (1 - distRatio) * 3 * dpr;
          const nodeR = 0.1 * distRatio; // INFRARED

          lctx.fillStyle = getSpectrumColor(nodeR, 0.9);
          lctx.beginPath();
          lctx.arc(node.x, node.y, size, 0, Math.PI*2);
          lctx.fill();

          // Node glow
          lctx.fillStyle = getSpectrumColor(nodeR, 0.2);
          lctx.beginPath();
          lctx.arc(node.x, node.y, size * 2, 0, Math.PI*2);
          lctx.fill();
        }
        lctx.globalAlpha = 1;
      }

      // R-fixed point indicator (Euler boundary)
      const Rstrength = state.R;
      const fixedness = markedness > 0.3 && markedness < 0.7 ? 1.0 : Rstrength; // Fixed at boundary

      if (fixedness > 0.5) {
        lctx.strokeStyle = 'rgba(68, 209, 141, 0.8)';
        lctx.lineWidth = 1.5*dpr;
        lctx.setLineDash([4*dpr, 4*dpr]);
        lctx.beginPath();
        lctx.arc(cx, cy, radius*1.15, 0, Math.PI*2);
        lctx.stroke();
        lctx.setLineDash([]);
      }

      // Update status
      const stateDesc = markedness < 0.3 ? 'Separated (unmarked)' : (markedness > 0.7 ? 'Crossed (marked)' : 'Crossing (boundary)');
      localCaption.textContent = `Lines ${stateDesc} — Circle ${markedness > 0.5 ? 'forming' : 'fading'} (${(phase/(Math.PI*2)*360).toFixed(0)}°)`;
      oscillatorState.textContent = 'Active';
      rfixedStatus.textContent = fixedness > 0.5 ? 'Yes' : 'No';
      oscillatorIndicator.className = 'status-indicator active';

      // Update syntax overlay (dynamic representations)
      // LoF notation: unmarked ⟨ ⟩ → boundary (( )) → marked ((( )))
      if (markedness < 0.3) {
        lofSyntax.textContent = '⟨ ⟩';  // Void/unmarked
      } else if (markedness < 0.7) {
        lofSyntax.textContent = '( )';  // The mark (Euler boundary)
      } else {
        lofSyntax.textContent = '(( ))';  // Marked/crossed
      }

      // Logic notation: void → mark → negation
      if (markedness < 0.3) {
        logicSyntax.textContent = '⊥ (void)';
      } else if (markedness < 0.7) {
        logicSyntax.textContent = '¬(·) (mark)';
      } else {
        logicSyntax.textContent = '¬¬(·) ≈ ·';
      }

      // Nucleus notation: showing R application
      const RVal = state.R.toFixed(2);
      if (fixedness > 0.5) {
        nucleusSyntax.textContent = `R(∂○) = ∂○ (fixed)`;
      } else {
        nucleusSyntax.textContent = `R^${RVal}(·) → ·`;
      }

      // Euler formula: e^(iθ) = cos(θ) + i·sin(θ)
      const theta = (phase/(Math.PI)*180).toFixed(0);
      const cosVal = Math.cos(phase).toFixed(2);
      const sinVal = Math.sin(phase).toFixed(2);
      eulerSyntax.textContent = `e^(i·${theta}°) = ${cosVal} + i·${sinVal}`;

    } else {
      // INACTIVE: Waiting for re-entry (show potential crossing)

      const radius = Math.min(W,H) * 0.25;

      // Faint potential circle (dashed, spectrum colored)
      lctx.strokeStyle = getSpectrumColor(state.R, 0.2);
      lctx.lineWidth = 1.5*dpr;
      lctx.setLineDash([6*dpr, 6*dpr]);
      lctx.beginPath();
      lctx.arc(cx, cy, radius, 0, Math.PI*2);
      lctx.stroke();
      lctx.setLineDash([]);

      // Two potential lines (faint, separated)
      const separation = radius * 0.8;
      const lineLength = radius * 1.2;

      // Left line (faint blue)
      lctx.strokeStyle = 'rgba(102, 217, 239, 0.25)';
      lctx.lineWidth = 2*dpr;
      lctx.beginPath();
      lctx.moveTo(cx - lineLength - separation, cy);
      lctx.lineTo(cx - separation, cy);
      lctx.stroke();

      // Right line (faint purple)
      lctx.strokeStyle = 'rgba(200, 140, 255, 0.25)';
      lctx.beginPath();
      lctx.moveTo(cx + lineLength + separation, cy);
      lctx.lineTo(cx + separation, cy);
      lctx.stroke();

      // Central "ready" indicator
      lctx.fillStyle = 'rgba(219, 230, 255, 0.3)';
      lctx.beginPath();
      lctx.arc(cx, cy, 4*dpr, 0, Math.PI*2);
      lctx.fill();

      localCaption.textContent = 'Awaiting re-entry — Lines ready to cross (click "Create Mark")';
      oscillatorState.textContent = 'Inactive';
      rfixedStatus.textContent = '—';
      oscillatorIndicator.className = 'status-indicator';

      // Update syntax overlay (inactive state - showing potential)
      lofSyntax.textContent = '⟨ ⟩';  // Unmarked void
      logicSyntax.textContent = '⊥ (void)';
      nucleusSyntax.textContent = `R: ${state.R.toFixed(2)} (ready)`;
      eulerSyntax.textContent = 'e^(i·0) = 1 + i·0';
    }
  }

  // === EVENT HANDLERS ===

  RSlider.addEventListener('input', (e) => {
    state.R = (+e.target.value) / 100;
    RValue.textContent = state.R.toFixed(2);
    state.oscillatorSpeed = 0.001 + state.R * 0.003; // R controls oscillation speed
  });

  nodesSlider.addEventListener('input', (e) => {
    state.nodes = +e.target.value;
    nodesValue.textContent = state.nodes === 64 ? '∞' : state.nodes;
  });

  btnCollapse.addEventListener('click', () => {
    state.collapsed = !state.collapsed;
    state.collapseTarget = state.collapsed ? 1 : 0;

    // Flash effect
    globalCanvas.animate([
      { filter: state.collapsed ? 'brightness(0.3)' : 'brightness(1.5)' },
      { filter: 'brightness(1)' }
    ], { duration: 600 });
  });

  btnOscillate.addEventListener('click', () => {
    state.oscillating = !state.oscillating;
    btnOscillate.textContent = state.oscillating ? 'Stop Oscillation' : 'Create Mark ¬(·)';

    if (state.oscillating) {
      state.oscillatorPhase = 0;
      localCanvas.animate([
        { filter: 'brightness(1.5) saturate(1.4)' },
        { filter: 'brightness(1)' }
      ], { duration: 700 });
    }
  });

  btnReset.addEventListener('click', () => {
    state.R = 0.50;
    state.nodes = 16;
    state.collapsed = false;
    state.collapseProgress = 0;
    state.collapseTarget = 0;
    state.oscillating = false;
    state.oscillatorPhase = 0;
    RSlider.value = 50;
    RValue.textContent = '0.50';
    nodesSlider.value = 16;
    nodesValue.textContent = '16';
    btnOscillate.textContent = 'Create Mark ¬(·)';
    drawGlobal();
    drawLocal();
  });

  // Keyboard shortcuts
  document.addEventListener('keydown', (e) => {
    if (e.key === 'c' || e.key === 'C') btnCollapse.click();
    if (e.key === 'm' || e.key === 'M') btnOscillate.click();
    if (e.key === 'r' || e.key === 'R') btnReset.click();
  });

  // === ANIMATION LOOP ===
  let lastTime = performance.now();

  function tick(now){
    const dt = Math.min(now - lastTime, 50);
    lastTime = now;

    // Animate collapse progress (smooth transition)
    const collapseSpeed = 0.003; // Collapse/expand speed
    if (state.collapseProgress < state.collapseTarget) {
      state.collapseProgress = Math.min(state.collapseTarget, state.collapseProgress + collapseSpeed * dt);
    } else if (state.collapseProgress > state.collapseTarget) {
      state.collapseProgress = Math.max(state.collapseTarget, state.collapseProgress - collapseSpeed * dt);
    }

    // Update oscillator phase
    if (state.oscillating) {
      state.oscillatorPhase += state.oscillatorSpeed * dt;
      if (state.oscillatorPhase > Math.PI * 2) {
        state.oscillatorPhase -= Math.PI * 2;
      }
    }

    drawGlobal();
    drawLocal();

    requestAnimationFrame(tick);
  }

  // Initialize
  RValue.textContent = state.R.toFixed(2);
  nodesValue.textContent = state.nodes;
  requestAnimationFrame(tick);
})();
</script>
</body>
</html>
