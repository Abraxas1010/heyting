window.depGraphData = {
  "edges": [
    {
      "source": "def:aggregate",
      "target": "def:aggregate-step"
    },
    {
      "source": "def:aggregate",
      "target": "def:breathing-angle"
    },
    {
      "source": "def:aggregate",
      "target": "def:kernel-data"
    },
    {
      "source": "def:aggregate",
      "target": "def:nucleus-closure"
    },
    {
      "source": "def:clifford-carrier",
      "target": "thm:clifford-rt"
    },
    {
      "source": "def:clifford-carrier",
      "target": "thm:clifford-stage"
    },
    {
      "source": "def:collapse-expand",
      "target": "def:breathe-birth"
    },
    {
      "source": "def:compliance-tests",
      "target": "thm:build-contract"
    },
    {
      "source": "def:counter-process",
      "target": "lem:process-ortho"
    },
    {
      "source": "def:euler-boundary",
      "target": "thm:euler-eq-process"
    },
    {
      "source": "def:graph-carrier",
      "target": "thm:graph-rt"
    },
    {
      "source": "def:graph-carrier",
      "target": "thm:graph-stage"
    },
    {
      "source": "def:heyting-nucleus",
      "target": "def:heyting-impl"
    },
    {
      "source": "def:journal-entry",
      "target": "def:aggregate"
    },
    {
      "source": "def:journal-entry",
      "target": "def:state"
    },
    {
      "source": "def:kernel-data",
      "target": "def:boundary-model"
    },
    {
      "source": "def:kernel-data",
      "target": "def:fiber-status"
    },
    {
      "source": "def:kernel-data",
      "target": "def:hypergraph-model"
    },
    {
      "source": "def:kernel-data",
      "target": "def:rpc-apply"
    },
    {
      "source": "def:omega",
      "target": "def:compliance-tests"
    },
    {
      "source": "def:omega",
      "target": "def:counter-process"
    },
    {
      "source": "def:omega",
      "target": "def:euler-boundary"
    },
    {
      "source": "def:omega",
      "target": "def:process"
    },
    {
      "source": "def:omega",
      "target": "def:residuated-ladder"
    },
    {
      "source": "def:omega",
      "target": "lem:process-ortho"
    },
    {
      "source": "def:omega",
      "target": "thm:clifford-rt"
    },
    {
      "source": "def:omega",
      "target": "thm:clifford-stage"
    },
    {
      "source": "def:omega",
      "target": "thm:double-neg"
    },
    {
      "source": "def:omega",
      "target": "thm:euler-eq-process"
    },
    {
      "source": "def:omega",
      "target": "thm:graph-rt"
    },
    {
      "source": "def:omega",
      "target": "thm:graph-stage"
    },
    {
      "source": "def:omega",
      "target": "thm:heyting-adjunction"
    },
    {
      "source": "def:omega",
      "target": "thm:heyting-instance"
    },
    {
      "source": "def:omega",
      "target": "thm:tensor-rt"
    },
    {
      "source": "def:omega",
      "target": "thm:tensor-stage"
    },
    {
      "source": "def:primary-algebra",
      "target": "def:breathe-birth"
    },
    {
      "source": "def:primary-algebra",
      "target": "def:clifford-carrier"
    },
    {
      "source": "def:primary-algebra",
      "target": "def:compliance-tests"
    },
    {
      "source": "def:primary-algebra",
      "target": "def:counter-process"
    },
    {
      "source": "def:primary-algebra",
      "target": "def:dialectic"
    },
    {
      "source": "def:primary-algebra",
      "target": "def:euler-boundary"
    },
    {
      "source": "def:primary-algebra",
      "target": "def:graph-carrier"
    },
    {
      "source": "def:primary-algebra",
      "target": "def:omega"
    },
    {
      "source": "def:primary-algebra",
      "target": "def:process"
    },
    {
      "source": "def:primary-algebra",
      "target": "def:psr"
    },
    {
      "source": "def:primary-algebra",
      "target": "def:reentry"
    },
    {
      "source": "def:primary-algebra",
      "target": "def:residuated-ladder"
    },
    {
      "source": "def:primary-algebra",
      "target": "def:tensor-carrier"
    },
    {
      "source": "def:primary-algebra",
      "target": "lem:nucleus-props"
    },
    {
      "source": "def:primary-algebra",
      "target": "lem:process-ortho"
    },
    {
      "source": "def:primary-algebra",
      "target": "thm:clifford-rt"
    },
    {
      "source": "def:primary-algebra",
      "target": "thm:clifford-stage"
    },
    {
      "source": "def:primary-algebra",
      "target": "thm:double-neg"
    },
    {
      "source": "def:primary-algebra",
      "target": "thm:euler-eq-process"
    },
    {
      "source": "def:primary-algebra",
      "target": "thm:graph-rt"
    },
    {
      "source": "def:primary-algebra",
      "target": "thm:graph-stage"
    },
    {
      "source": "def:primary-algebra",
      "target": "thm:heyting-adjunction"
    },
    {
      "source": "def:primary-algebra",
      "target": "thm:heyting-instance"
    },
    {
      "source": "def:primary-algebra",
      "target": "thm:tensor-rt"
    },
    {
      "source": "def:primary-algebra",
      "target": "thm:tensor-stage"
    },
    {
      "source": "def:primitives",
      "target": "def:aggregate-step"
    },
    {
      "source": "def:primitives",
      "target": "def:certificates"
    },
    {
      "source": "def:primitives",
      "target": "def:clifford-carrier"
    },
    {
      "source": "def:primitives",
      "target": "def:dial-stages"
    },
    {
      "source": "def:primitives",
      "target": "def:dialectic"
    },
    {
      "source": "def:primitives",
      "target": "def:graph-carrier"
    },
    {
      "source": "def:primitives",
      "target": "def:heyting-nucleus"
    },
    {
      "source": "def:primitives",
      "target": "def:journal-entry"
    },
    {
      "source": "def:primitives",
      "target": "def:lens"
    },
    {
      "source": "def:primitives",
      "target": "def:occam"
    },
    {
      "source": "def:primitives",
      "target": "def:primary-algebra"
    },
    {
      "source": "def:primitives",
      "target": "def:proof-handle"
    },
    {
      "source": "def:primitives",
      "target": "def:proof-normalize"
    },
    {
      "source": "def:primitives",
      "target": "def:psr"
    },
    {
      "source": "def:primitives",
      "target": "def:region-cycle"
    },
    {
      "source": "def:primitives",
      "target": "def:residuated-ladder"
    },
    {
      "source": "def:primitives",
      "target": "def:stage-semantics"
    },
    {
      "source": "def:primitives",
      "target": "def:stepper"
    },
    {
      "source": "def:primitives",
      "target": "def:tensor-carrier"
    },
    {
      "source": "def:primitives",
      "target": "def:visual-modes"
    },
    {
      "source": "def:process",
      "target": "def:euler-boundary"
    },
    {
      "source": "def:process",
      "target": "lem:process-ortho"
    },
    {
      "source": "def:process",
      "target": "thm:euler-eq-process"
    },
    {
      "source": "def:proof-handle",
      "target": "def:proof-graph"
    },
    {
      "source": "def:proof-handle",
      "target": "def:proof-normalize"
    },
    {
      "source": "def:reentry",
      "target": "def:compliance-tests"
    },
    {
      "source": "def:reentry",
      "target": "def:counter-process"
    },
    {
      "source": "def:reentry",
      "target": "def:dialectic"
    },
    {
      "source": "def:reentry",
      "target": "def:euler-boundary"
    },
    {
      "source": "def:reentry",
      "target": "def:omega"
    },
    {
      "source": "def:reentry",
      "target": "def:process"
    },
    {
      "source": "def:reentry",
      "target": "def:psr"
    },
    {
      "source": "def:reentry",
      "target": "def:residuated-ladder"
    },
    {
      "source": "def:reentry",
      "target": "lem:nucleus-props"
    },
    {
      "source": "def:reentry",
      "target": "lem:process-ortho"
    },
    {
      "source": "def:reentry",
      "target": "thm:double-neg"
    },
    {
      "source": "def:reentry",
      "target": "thm:euler-eq-process"
    },
    {
      "source": "def:reentry",
      "target": "thm:heyting-adjunction"
    },
    {
      "source": "def:reentry",
      "target": "thm:heyting-instance"
    },
    {
      "source": "def:stage-semantics",
      "target": "def:collapse-expand"
    },
    {
      "source": "def:state",
      "target": "def:kernel-data"
    },
    {
      "source": "def:state",
      "target": "def:rpc-apply"
    },
    {
      "source": "def:state",
      "target": "def:stepper"
    },
    {
      "source": "def:tensor-carrier",
      "target": "thm:tensor-rt"
    },
    {
      "source": "def:tensor-carrier",
      "target": "thm:tensor-stage"
    },
    {
      "source": "thm:clifford-rt",
      "target": "def:compliance-tests"
    },
    {
      "source": "thm:clifford-rt",
      "target": "thm:clifford-stage"
    },
    {
      "source": "thm:graph-rt",
      "target": "def:compliance-tests"
    },
    {
      "source": "thm:graph-rt",
      "target": "thm:graph-stage"
    },
    {
      "source": "thm:heyting-adjunction",
      "target": "thm:double-neg"
    },
    {
      "source": "thm:heyting-instance",
      "target": "thm:clifford-stage"
    },
    {
      "source": "thm:heyting-instance",
      "target": "thm:double-neg"
    },
    {
      "source": "thm:heyting-instance",
      "target": "thm:heyting-adjunction"
    },
    {
      "source": "thm:tensor-rt",
      "target": "def:compliance-tests"
    },
    {
      "source": "thm:tensor-rt",
      "target": "thm:tensor-stage"
    }
  ],
  "nodes": [
    {
      "id": "def:aggregate",
      "isPlaceholder": false,
      "kind": "definition",
      "lean": null,
      "leanDeps": [],
      "leanDoc": null,
      "leanFound": false,
      "name": "Aggregate",
      "shape": "box",
      "status": "statement-ready",
      "summary": "The aggregate state tracks: - current: Current region subset (represents the nucleus state) - previous: Previous region subset (for comparisons) - stack: Stack of active regions (for unmark discipline) - marks, unmarks, reentries: Interaction counters",
      "url": "../web/sec-aggregate.html#def:aggregate"
    },
    {
      "id": "def:aggregate-step",
      "isPlaceholder": false,
      "kind": "definition",
      "lean": null,
      "leanDeps": [],
      "leanDoc": null,
      "leanFound": false,
      "name": "Aggregate Step",
      "shape": "box",
      "status": "statement-ready",
      "summary": "Each primitive updates the aggregate: - Mark: Insert next region, push to stack, increment mark counter - Unmark: Pop from stack, remove region from current set, increment unmark counter - Re-entry: Apply nucleus closure, merge additions into stack, increment re-entry counter",
      "url": "../web/sec-aggregate.html#def:aggregate-step"
    },
    {
      "id": "def:boundary-model",
      "isPlaceholder": false,
      "kind": "definition",
      "lean": null,
      "leanDeps": [],
      "leanDoc": null,
      "leanFound": false,
      "name": "Boundary Model",
      "shape": "box",
      "status": "statement-ready",
      "summary": "Boundary models derive geometric parameters (radii, positions, nesting depth) from nucleus cardinals with certified coupling lemmas.",
      "url": "../web/sec-render-models.html#def:boundary-model"
    },
    {
      "id": "def:breathe-birth",
      "isPlaceholder": false,
      "kind": "definition",
      "lean": "HeytingLean.Logic.Modal.DialParam.breathe",
      "leanDeps": [
        "HeytingLean.LoF.PrimaryAlgebra",
        "HeytingLean.Logic.Modal.DialParam",
        "Prod",
        "Prod.mk",
        "DFunLike.coe",
        "Nucleus",
        "Lattice.toSemilatticeInf",
        "ConditionallyCompleteLattice.toLattice",
        "CompleteLattice.toConditionallyCompleteLattice",
        "Order.Frame.toCompleteLattice",
        "HeytingLean.LoF.PrimaryAlgebra.toFrame",
        "Nucleus.instFunLike",
        "HeytingLean.LoF.Reentry.nucleus",
        "HeytingLean.Logic.Modal.Dial.box",
        "HeytingLean.Logic.Modal.DialParam.dial",
        "HeytingLean.Logic.Modal.Dial.diamond"
      ],
      "leanDoc": "The breathing endpoints packaged as a pair. ",
      "leanFound": true,
      "name": "Breathe and Birth",
      "shape": "box",
      "status": "formalized",
      "summary": "Dynamic reasoning operators: - breathe: Cyclic collapse-expand transformation - birth: Emergence from ground state",
      "url": "../web/sec-modal-breathing.html#def:breathe-birth"
    },
    {
      "id": "def:breathing-angle",
      "isPlaceholder": false,
      "kind": "definition",
      "lean": null,
      "leanDeps": [],
      "leanDoc": null,
      "leanFound": false,
      "name": "Breathing Angle",
      "shape": "box",
      "status": "statement-ready",
      "summary": "A synthetic breathing angle $\\theta$ derived from interaction counts: \\[ \\theta = (90 \\cdot reentries + 30 \\cdot marks - 20 \\cdot unmarks) \\bmod 360 \\]",
      "url": "../web/sec-breathing-angle.html#def:breathing-angle"
    },
    {
      "id": "def:certificates",
      "isPlaceholder": false,
      "kind": "definition",
      "lean": null,
      "leanDeps": [],
      "leanDoc": null,
      "leanFound": false,
      "name": "Certificate Bundle",
      "shape": "box",
      "status": "statement-ready",
      "summary": "Each render carries proof certificates: - adjunction: Does previous satisfy $prev \\subseteq (curr \\Rightarrow closure(curr))$? - rt\u2081: Is previous a nucleus fixed point? - rt\u2082: Is current a nucleus fixed point? - classicalized: Is the dial at the sphere stage?",
      "url": "../web/sec-certificates.html#def:certificates"
    },
    {
      "id": "def:clifford-carrier",
      "isPlaceholder": false,
      "kind": "definition",
      "lean": "HeytingLean.Bridges.Clifford.Model.Carrier",
      "leanDeps": [
        "HeytingLean.LoF.PrimaryAlgebra",
        "HeytingLean.Bridges.Clifford.Model",
        "HeytingLean.Bridges.Clifford.Pair"
      ],
      "leanDoc": null,
      "leanFound": true,
      "name": "Clifford Carrier",
      "shape": "box",
      "status": "formalized",
      "summary": "The Clifford bridge embeds LoF states into Clifford algebras via geometric projectors and bivectors.",
      "url": "../web/sec-clifford-bridge.html#def:clifford-carrier"
    },
    {
      "id": "def:collapse-expand",
      "isPlaceholder": false,
      "kind": "definition",
      "lean": null,
      "leanDeps": [],
      "leanDoc": null,
      "leanFound": false,
      "name": "Collapse and Expand",
      "shape": "box",
      "status": "statement-ready",
      "summary": "Modal operators transform between dial stages: - collapseAt: Descend one stage - expandAt: Ascend one stage",
      "url": "../web/sec-modal-breathing.html#def:collapse-expand"
    },
    {
      "id": "def:compliance-tests",
      "isPlaceholder": false,
      "kind": "definition",
      "lean": "HeytingLean.Tests.identity_round_verified",
      "leanDeps": [
        "HeytingLean.LoF.PrimaryAlgebra",
        "HeytingLean.LoF.Reentry",
        "HeytingLean.LoF.Reentry.Omega",
        "Eq",
        "HeytingLean.Contracts.RoundTrip.decode",
        "HeytingLean.Contracts.Examples.identity",
        "HeytingLean.Contracts.RoundTrip.encode",
        "HeytingLean.Contracts.Examples.identity_round"
      ],
      "leanDoc": null,
      "leanFound": true,
      "name": "Compliance Tests",
      "shape": "box",
      "status": "formalized",
      "summary": "The compliance suite validates: - Round-trip contracts (RT-1, RT-2) for all bridges - Triad contracts (TRI-1, TRI-2) for cross-lens coherence - Stage transport preservation across dial operations - Kernel invariants under journal replay - Renderer model coupling lemmas",
      "url": "../web/sec-compliance.html#def:compliance-tests"
    },
    {
      "id": "def:counter-process",
      "isPlaceholder": false,
      "kind": "definition",
      "lean": "HeytingLean.LoF.Reentry.counterProcess",
      "leanDeps": [
        "HeytingLean.LoF.PrimaryAlgebra",
        "HeytingLean.LoF.Reentry",
        "HeytingLean.LoF.Reentry.Omega",
        "HeytingLean.LoF.Reentry.Omega.mk",
        "HeytingLean.LoF.Reentry.counter",
        "HeytingLean.LoF.Reentry.counter_mem"
      ],
      "leanDoc": "The complementary fixed point capturing the counter-process. ",
      "leanFound": true,
      "name": "Counter-Process",
      "shape": "box",
      "status": "formalized",
      "summary": "The counter-process is the complementary fixed point in $\\Omega_R$.",
      "url": "../web/sec-processes.html#def:counter-process"
    },
    {
      "id": "def:dial-stages",
      "isPlaceholder": false,
      "kind": "definition",
      "lean": null,
      "leanDeps": [],
      "leanDoc": null,
      "leanFound": false,
      "name": "Dial Stages",
      "shape": "box",
      "status": "statement-ready",
      "summary": "Four dimensional stages govern algebraic interpretations: - S0 (Ontic): Ground level, minimal structure - S1 (Symbolic): Symbolic logic layer - S2 (Circle): Circular/periodic dynamics - S3 (Sphere): Full classical logic (Boolean limit)",
      "url": "../web/sec-dial-stages.html#def:dial-stages"
    },
    {
      "id": "def:dialectic",
      "isPlaceholder": false,
      "kind": "definition",
      "lean": "HeytingLean.Logic.Dialectic.synth",
      "leanDeps": [
        "HeytingLean.LoF.PrimaryAlgebra",
        "HeytingLean.LoF.Reentry",
        "DFunLike.coe",
        "Nucleus",
        "Lattice.toSemilatticeInf",
        "ConditionallyCompleteLattice.toLattice",
        "CompleteLattice.toConditionallyCompleteLattice",
        "Order.Frame.toCompleteLattice",
        "HeytingLean.LoF.PrimaryAlgebra.toFrame",
        "Nucleus.instFunLike",
        "HeytingLean.LoF.Reentry.nucleus",
        "Max.max",
        "SemilatticeSup.toMax",
        "Lattice.toSemilatticeSup"
      ],
      "leanDoc": "Dialectic synthesis: close the union of thesis and antithesis under the re-entry nucleus. ",
      "leanFound": true,
      "name": "Dialectic Operator",
      "shape": "box",
      "status": "formalized",
      "summary": "The dialectic operator mediates between process and counter-process through Heyting implication.",
      "url": "../web/sec-dialectic.html#def:dialectic"
    },
    {
      "id": "def:euler-boundary",
      "isPlaceholder": false,
      "kind": "definition",
      "lean": "HeytingLean.LoF.Reentry.eulerBoundary",
      "leanDeps": [
        "HeytingLean.LoF.PrimaryAlgebra",
        "HeytingLean.LoF.Reentry",
        "HeytingLean.LoF.Reentry.Omega",
        "InfSet.sInf",
        "Sublocale.carrier.instInfSet",
        "HeytingLean.LoF.PrimaryAlgebra.toFrame",
        "Nucleus.toSublocale",
        "HeytingLean.LoF.Reentry.nucleus",
        "HeytingLean.LoF.Reentry.boundaryCandidates"
      ],
      "leanDoc": "The Euler boundary is the infimum of all nontrivial fixed points. ",
      "leanFound": true,
      "name": "Euler Boundary",
      "shape": "box",
      "status": "formalized",
      "summary": "The Euler boundary is the infimum of all nontrivial fixed points in $\\Omega_R$.",
      "url": "../web/sec-euler-boundary.html#def:euler-boundary"
    },
    {
      "id": "def:fiber-status",
      "isPlaceholder": false,
      "kind": "definition",
      "lean": null,
      "leanDeps": [],
      "leanDoc": null,
      "leanFound": false,
      "name": "Fiber Status",
      "shape": "box",
      "status": "statement-ready",
      "summary": "Fiber status flags track lens-specific invariants: - logicStable: Current set is a nucleus fixed point - tensorBounded: Region count within linear capacity - graphActivated: Re-entry observed in journal - cliffordEven: Mark parity is even (dualised vs. torsion)",
      "url": "../web/sec-render-models.html#def:fiber-status"
    },
    {
      "id": "def:graph-carrier",
      "isPlaceholder": false,
      "kind": "definition",
      "lean": "HeytingLean.Bridges.Graph.Model.Carrier",
      "leanDeps": [
        "HeytingLean.LoF.PrimaryAlgebra",
        "HeytingLean.Bridges.Graph.Model"
      ],
      "leanDoc": null,
      "leanFound": true,
      "name": "Graph Carrier",
      "shape": "box",
      "status": "formalized",
      "summary": "The graph bridge interprets LoF states as Alexandroff topological spaces with graph adjacency.",
      "url": "../web/sec-graph-bridge.html#def:graph-carrier"
    },
    {
      "id": "def:heyting-impl",
      "isPlaceholder": false,
      "kind": "definition",
      "lean": null,
      "leanDeps": [],
      "leanDoc": null,
      "leanFound": false,
      "name": "Heyting Implication",
      "shape": "box",
      "status": "statement-ready",
      "summary": "Heyting implication in the toy lattice: \\[ a \\Rightarrow b := nucleus((universe \\setminus a) \\cup b) \\]",
      "url": "../web/sec-kernel-data.html#def:heyting-impl"
    },
    {
      "id": "def:heyting-nucleus",
      "isPlaceholder": false,
      "kind": "definition",
      "lean": null,
      "leanDeps": [],
      "leanDoc": null,
      "leanFound": false,
      "name": "Heyting Nucleus",
      "shape": "box",
      "status": "statement-ready",
      "summary": "The canonical Heyting nucleus used for proof calculations: \\[ nucleus(S) = cases universe & if \\alpha \\in S \\\\ S \\cup \\ & otherwise cases \\]",
      "url": "../web/sec-kernel-data.html#def:heyting-nucleus"
    },
    {
      "id": "def:hypergraph-model",
      "isPlaceholder": false,
      "kind": "definition",
      "lean": null,
      "leanDeps": [],
      "leanDoc": null,
      "leanFound": false,
      "name": "Hypergraph Model",
      "shape": "box",
      "status": "statement-ready",
      "summary": "Hypergraph models expose re-entry preorder as directed hyperedges connecting region subsets.",
      "url": "../web/sec-render-models.html#def:hypergraph-model"
    },
    {
      "id": "def:journal-entry",
      "isPlaceholder": false,
      "kind": "definition",
      "lean": "HeytingLean.ProofWidgets.LoFViz.JournalEntry",
      "leanDeps": [],
      "leanDoc": "Internal journal entry for primitives. ",
      "leanFound": true,
      "name": "Journal Entry",
      "shape": "box",
      "status": "formalized",
      "summary": "Each primitive interaction is recorded as a journal entry with a monotone timestamp, enabling deterministic replay and proof analysis.",
      "url": "../web/sec-journal.html#def:journal-entry"
    },
    {
      "id": "def:kernel-data",
      "isPlaceholder": false,
      "kind": "definition",
      "lean": null,
      "leanDeps": [],
      "leanDoc": null,
      "leanFound": false,
      "name": "Kernel Data",
      "shape": "box",
      "status": "statement-ready",
      "summary": "Kernel data packages the state, computed aggregate, and summary statistics for visualization.",
      "url": "../web/sec-kernel-data.html#def:kernel-data"
    },
    {
      "id": "def:lens",
      "isPlaceholder": false,
      "kind": "definition",
      "lean": null,
      "leanDeps": [],
      "leanDoc": null,
      "leanFound": false,
      "name": "Lens Selection",
      "shape": "box",
      "status": "statement-ready",
      "summary": "Four bridge lenses provide different algebraic perspectives: - Logic: Direct Heyting interpretation - Tensor: Tensor product representation with intensity - Graph: Alexandroff topology and graph carriers - Clifford: Clifford algebra with geometric projectors",
      "url": "../web/sec-lenses.html#def:lens"
    },
    {
      "id": "def:nucleus-closure",
      "isPlaceholder": false,
      "kind": "definition",
      "lean": null,
      "leanDeps": [],
      "leanDoc": null,
      "leanFound": false,
      "name": "Nucleus Closure",
      "shape": "box",
      "status": "statement-ready",
      "summary": "The toy LoF nucleus closure operates on region sets: \\[ closure(S, n) = cases universe & if \\alpha \\in S \\land n \\equiv 1 2 \\\\ S \\cup \\ & if \\alpha \\in S \\land n \\equiv 0 2 \\\\ S \\cup \\ & otherwise cases \\] where $n$ is the re-entry counter.",
      "url": "../web/sec-toy-nucleus.html#def:nucleus-closure"
    },
    {
      "id": "def:occam",
      "isPlaceholder": false,
      "kind": "definition",
      "lean": null,
      "leanDeps": [],
      "leanDoc": null,
      "leanFound": false,
      "name": "Occam Reduction",
      "shape": "box",
      "status": "statement-ready",
      "summary": "Occam's reduction eliminates redundant structure, collapsing representations to minimal normal forms.",
      "url": "../web/sec-occam.html#def:occam"
    },
    {
      "id": "def:omega",
      "isPlaceholder": false,
      "kind": "definition",
      "lean": "HeytingLean.LoF.Reentry.Omega",
      "leanDeps": [
        "HeytingLean.LoF.PrimaryAlgebra",
        "HeytingLean.LoF.Reentry",
        "Subtype",
        "Membership.mem",
        "Sublocale",
        "HeytingLean.LoF.PrimaryAlgebra.toFrame",
        "SetLike.instMembership",
        "Sublocale.instSetLike",
        "Nucleus.toSublocale",
        "HeytingLean.LoF.Reentry.nucleus"
      ],
      "leanDoc": "Fixed points of the nucleus viewed as the associated sublocale `\u03a9_R`. ",
      "leanFound": true,
      "name": "Fixed-Point Sublocale",
      "shape": "box",
      "status": "formalized",
      "summary": "The Heyting core $\\Omega_R$ is the sublocale of fixed points: $\\Omega_R := \\ x : \\alpha \\mid R(x) = x\\ $.",
      "url": "../web/sec-heyting-core.html#def:omega"
    },
    {
      "id": "def:primary-algebra",
      "isPlaceholder": false,
      "kind": "definition",
      "lean": "HeytingLean.LoF.PrimaryAlgebra",
      "leanDeps": [],
      "leanDoc": "`PrimaryAlgebra \u03b1` packages the LoF base assumptions as a frame.\n\nThe frame requirement ensures finite meets distribute over arbitrary joins, matching the locale\ninterpretation of the primary algebra that underpins the nucleus story. ",
      "leanFound": true,
      "name": "Primary Algebra",
      "shape": "box",
      "status": "formalized",
      "summary": "A primary algebra is a type $\\alpha$ equipped with a frame structure, ensuring finite meets distribute over arbitrary joins. This provides the locale interpretation underlying the nucleus story.",
      "url": "../web/sec-primary-algebra.html#def:primary-algebra"
    },
    {
      "id": "def:primitives",
      "isPlaceholder": false,
      "kind": "definition",
      "lean": "HeytingLean.ProofWidgets.LoFViz.Primitive",
      "leanDeps": [],
      "leanDoc": "Primitive interactions exposed in the UI. ",
      "leanFound": true,
      "name": "Primitive Operators",
      "shape": "box",
      "status": "formalized",
      "summary": "The LoF calculus is built on three atomic interactions: - Mark (.mark): Creates a new boundary distinction, introducing a fresh region - Unmark (.unmark): Removes the most recently marked boundary - Re-entry (.reentry): Applies the nucleus closure operation, generating fixed points",
      "url": "../web/sec-primitives.html#def:primitives"
    },
    {
      "id": "def:process",
      "isPlaceholder": false,
      "kind": "definition",
      "lean": "HeytingLean.LoF.Reentry.process",
      "leanDeps": [
        "HeytingLean.LoF.PrimaryAlgebra",
        "HeytingLean.LoF.Reentry",
        "HeytingLean.LoF.Reentry.Omega",
        "HeytingLean.LoF.Reentry.Omega.mk",
        "HeytingLean.LoF.Reentry.primordial",
        "HeytingLean.LoF.Reentry.primordial_mem"
      ],
      "leanDoc": "The primordial fixed point as an inhabitant of `\u03a9_R`. ",
      "leanFound": true,
      "name": "Primordial Process",
      "shape": "box",
      "status": "formalized",
      "summary": "The process is the primordial fixed point viewed as an element of $\\Omega_R$.",
      "url": "../web/sec-processes.html#def:process"
    },
    {
      "id": "def:proof-graph",
      "isPlaceholder": false,
      "kind": "definition",
      "lean": "HeytingLean.ProofWidgets.LoFViz.Proof.Graph.ProofGraph",
      "leanDeps": [],
      "leanDoc": "Full graph bundle produced for each proof constant. ",
      "leanFound": true,
      "name": "Proof Graph",
      "shape": "box",
      "status": "formalized",
      "summary": "A proof graph structure with nodes (propositions, tactics) and edges (dependencies, applications).",
      "url": "../web/sec-proof-graph.html#def:proof-graph"
    },
    {
      "id": "def:proof-handle",
      "isPlaceholder": false,
      "kind": "definition",
      "lean": null,
      "leanDeps": [],
      "leanDoc": null,
      "leanFound": false,
      "name": "Proof Handle",
      "shape": "box",
      "status": "statement-ready",
      "summary": "A proof handle caches statement and provenance for downstream display.",
      "url": "../web/sec-proof-ingestion.html#def:proof-handle"
    },
    {
      "id": "def:proof-normalize",
      "isPlaceholder": false,
      "kind": "definition",
      "lean": null,
      "leanDeps": [],
      "leanDoc": null,
      "leanFound": false,
      "name": "Proof Normalization",
      "shape": "box",
      "status": "statement-ready",
      "summary": "Proof normalization walks expression trees mapping: - Lambda/forall/let $\\mapsto$ Mark/Unmark - Self-recursion $\\mapsto$ Re-entry - Default: [Mark, Re-entry, Unmark] if no structure detected",
      "url": "../web/sec-proof-ingestion.html#def:proof-normalize"
    },
    {
      "id": "def:psr",
      "isPlaceholder": false,
      "kind": "definition",
      "lean": "HeytingLean.Logic.PSR.Sufficient",
      "leanDeps": [
        "HeytingLean.LoF.PrimaryAlgebra",
        "HeytingLean.LoF.Reentry",
        "Eq",
        "DFunLike.coe",
        "Nucleus",
        "Lattice.toSemilatticeInf",
        "ConditionallyCompleteLattice.toLattice",
        "CompleteLattice.toConditionallyCompleteLattice",
        "Order.Frame.toCompleteLattice",
        "HeytingLean.LoF.PrimaryAlgebra.toFrame",
        "Nucleus.instFunLike",
        "HeytingLean.LoF.Reentry.nucleus"
      ],
      "leanDoc": "The Principle of Sufficient Reason: a proposition is sufficient precisely when it is invariant\nunder the re-entry nucleus. ",
      "leanFound": true,
      "name": "PSR",
      "shape": "box",
      "status": "formalized",
      "summary": "The principle of sufficient reason ensures that every distinction has a generative nucleus witness.",
      "url": "../web/sec-psr.html#def:psr"
    },
    {
      "id": "def:reentry",
      "isPlaceholder": false,
      "kind": "definition",
      "lean": "HeytingLean.LoF.Reentry",
      "leanDeps": [
        "HeytingLean.LoF.PrimaryAlgebra"
      ],
      "leanDoc": "`Reentry \u03b1` packages the re-entry operation as a nucleus on a primary algebra together with\nthe minimal pair of complementary fixed points generated by the primordial distinction. ",
      "leanFound": true,
      "name": "Re-entry Structure",
      "shape": "box",
      "status": "formalized",
      "summary": "A re-entry operation on a primary algebra $\\alpha$ consists of: - A nucleus $R : \\alpha \\to \\alpha$ (idempotent, inflationary, inf-preserving) - A primordial fixed point: $R(primordial) = primordial$ - A counter fixed point: $R(counter) = counter$ - Orthogonality: $primordial \\sqcap counter = \\bot$ - Minimality: primordial is the least nontrivial fixed point",
      "url": "../web/sec-nucleus.html#def:reentry"
    },
    {
      "id": "def:region-cycle",
      "isPlaceholder": false,
      "kind": "definition",
      "lean": null,
      "leanDeps": [],
      "leanDoc": null,
      "leanFound": false,
      "name": "Region Cycle",
      "shape": "box",
      "status": "statement-ready",
      "summary": "Regions are named cyclically: $\\alpha, \\beta, \\gamma, \\delta$. The core region is $\\alpha$, and the satellite region is $\\delta$.",
      "url": "../web/sec-region-model.html#def:region-cycle"
    },
    {
      "id": "def:residuated-ladder",
      "isPlaceholder": false,
      "kind": "definition",
      "lean": "HeytingLean.Logic.Residuated.abduction",
      "leanDeps": [
        "HeytingLean.LoF.PrimaryAlgebra",
        "HeytingLean.LoF.Reentry",
        "HeytingLean.LoF.Reentry.Omega",
        "LE.le",
        "Subtype.instLE",
        "Preorder.toLE",
        "PartialOrder.toPreorder",
        "CompleteSemilatticeInf.toPartialOrder",
        "CompleteLattice.toCompleteSemilatticeInf",
        "Order.Frame.toCompleteLattice",
        "HeytingLean.LoF.PrimaryAlgebra.toFrame",
        "Membership.mem",
        "Sublocale",
        "SetLike.instMembership",
        "Sublocale.instSetLike",
        "Nucleus.toSublocale",
        "HeytingLean.LoF.Reentry.nucleus",
        "HImp.himp",
        "Sublocale.carrier.instHImp"
      ],
      "leanDoc": "Abduction captures the `B \u2264 A \u21d2 C` face of residuation. ",
      "leanFound": true,
      "name": "Residuated Ladder",
      "shape": "box",
      "status": "formalized",
      "summary": "A residuated ladder equips a type with multiplication and division operators satisfying residuation.",
      "url": "../web/sec-residuated-ladder.html#def:residuated-ladder"
    },
    {
      "id": "def:rpc-apply",
      "isPlaceholder": false,
      "kind": "definition",
      "lean": null,
      "leanDeps": [],
      "leanDoc": null,
      "leanFound": false,
      "name": "RPC Method",
      "shape": "box",
      "status": "statement-ready",
      "summary": "The apply RPC method: - Receives an event from the widget - Updates scene state via stepper - Rebuilds kernel data from journal - Routes to appropriate renderer - Returns BridgeResult with SVG + proof certificates",
      "url": "../web/sec-rpc.html#def:rpc-apply"
    },
    {
      "id": "def:stage-semantics",
      "isPlaceholder": false,
      "kind": "definition",
      "lean": "HeytingLean.Logic.Stage.MvCore",
      "leanDeps": [],
      "leanDoc": "\u0141ukasiewicz / MV-style structure available on the core carrier. ",
      "leanFound": true,
      "name": "Stage Semantics",
      "shape": "box",
      "status": "formalized",
      "summary": "Stage semantics layer provides MV-addition, effect algebra operations, and orthomodular structure operations that vary by dial stage.",
      "url": "../web/sec-stage-semantics.html#def:stage-semantics"
    },
    {
      "id": "def:state",
      "isPlaceholder": false,
      "kind": "definition",
      "lean": "HeytingLean.ProofWidgets.LoFViz.State",
      "leanDeps": [],
      "leanDoc": "State tracked per scene. ",
      "leanFound": true,
      "name": "Widget State",
      "shape": "box",
      "status": "formalized",
      "summary": "The global state tracks: - journal: Array of primitive interactions - dialStage: Current dimensional stage (ontic, symbolic, circle, sphere) - lens: Selected bridge lens (logic, tensor, graph, clifford) - mode: Visualization mode (boundary, euler, hypergraph, fiber, string, split) - nextStamp: Monotone timestamp counter",
      "url": "../web/sec-journal.html#def:state"
    },
    {
      "id": "def:stepper",
      "isPlaceholder": false,
      "kind": "definition",
      "lean": "HeytingLean.ProofWidgets.LoFViz.Stepper.applyEvent",
      "leanDeps": [
        "HeytingLean.ProofWidgets.LoFViz.State",
        "HeytingLean.ProofWidgets.LoFViz.Event",
        "HeytingLean.ProofWidgets.LoFViz.instReprEventKind.repr.match_1",
        "HeytingLean.ProofWidgets.LoFViz.EventKind",
        "HeytingLean.ProofWidgets.LoFViz.Event.kind",
        "Unit",
        "HeytingLean.ProofWidgets.LoFViz.Stepper.applyEvent.match_1",
        "Option",
        "HeytingLean.ProofWidgets.LoFViz.Primitive",
        "HeytingLean.ProofWidgets.LoFViz.Event.primitive?",
        "HeytingLean.ProofWidgets.LoFViz.Stepper.applyPrimitive",
        "HeytingLean.ProofWidgets.LoFViz.Stepper.applyEvent.match_3",
        "HeytingLean.ProofWidgets.LoFViz.DialStage",
        "HeytingLean.ProofWidgets.LoFViz.Event.dialStage?",
        "HeytingLean.ProofWidgets.LoFViz.State.mk",
        "HeytingLean.ProofWidgets.LoFViz.State.sceneId",
        "HeytingLean.ProofWidgets.LoFViz.State.journal",
        "HeytingLean.ProofWidgets.LoFViz.State.lens",
        "HeytingLean.ProofWidgets.LoFViz.State.mode",
        "HeytingLean.ProofWidgets.LoFViz.State.nextStamp",
        "HeytingLean.ProofWidgets.LoFViz.Stepper.applyEvent.match_5",
        "HeytingLean.ProofWidgets.LoFViz.Lens",
        "HeytingLean.ProofWidgets.LoFViz.Event.lens?",
        "HeytingLean.ProofWidgets.LoFViz.State.dialStage",
        "HeytingLean.ProofWidgets.LoFViz.Stepper.applyEvent.match_7",
        "HeytingLean.ProofWidgets.LoFViz.VisualMode",
        "HeytingLean.ProofWidgets.LoFViz.Event.mode?"
      ],
      "leanDoc": "Interpret an incoming event, updating the state. ",
      "leanFound": true,
      "name": "State Stepper",
      "shape": "box",
      "status": "formalized",
      "summary": "The stepper function applyEvent : State \u2192 Event \u2192 State is a pure state transition that appends primitives to the journal and updates control parameters (dial, lens, mode).",
      "url": "../web/sec-stepper.html#def:stepper"
    },
    {
      "id": "def:tensor-carrier",
      "isPlaceholder": false,
      "kind": "definition",
      "lean": "HeytingLean.Bridges.Tensor.Model.Carrier",
      "leanDeps": [
        "HeytingLean.LoF.PrimaryAlgebra",
        "HeytingLean.Bridges.Tensor.Model",
        "HeytingLean.Bridges.Tensor.Point",
        "HeytingLean.Bridges.Tensor.Model.dim"
      ],
      "leanDoc": null,
      "leanFound": true,
      "name": "Tensor Carrier",
      "shape": "box",
      "status": "formalized",
      "summary": "The tensor bridge represents LoF states as tensor product structures with intensity fields.",
      "url": "../web/sec-tensor-bridge.html#def:tensor-carrier"
    },
    {
      "id": "def:visual-modes",
      "isPlaceholder": false,
      "kind": "definition",
      "lean": null,
      "leanDeps": [],
      "leanDoc": null,
      "leanFound": false,
      "name": "Visualization Modes",
      "shape": "box",
      "status": "statement-ready",
      "summary": "Six rendering modes visualize different aspects: - Boundary: Traditional LoF boundary notation with nested regions - Euler: Euler diagram representation showing region overlaps - Hypergraph: Re-entry dependencies as hypergraph edges - Fiber: Bridge transports as fiber bundle visualization - String: Process/counter-process timeline strings - Split: Side-by-side comparative dashboard",
      "url": "../web/sec-visual-modes.html#def:visual-modes"
    },
    {
      "id": "lem:nucleus-props",
      "isPlaceholder": false,
      "kind": "lemma",
      "lean": "HeytingLean.LoF.Reentry.idempotent",
      "leanDeps": [
        "HeytingLean.LoF.PrimaryAlgebra",
        "HeytingLean.LoF.Reentry",
        "Eq",
        "DFunLike.coe",
        "Nucleus",
        "Lattice.toSemilatticeInf",
        "ConditionallyCompleteLattice.toLattice",
        "CompleteLattice.toConditionallyCompleteLattice",
        "Order.Frame.toCompleteLattice",
        "HeytingLean.LoF.PrimaryAlgebra.toFrame",
        "Nucleus.instFunLike",
        "HeytingLean.LoF.Reentry.nucleus",
        "Nucleus.idempotent"
      ],
      "leanDoc": null,
      "leanFound": true,
      "name": "Nucleus Properties",
      "shape": "ellipse",
      "status": "formalized",
      "summary": "\\leanok For any re-entry nucleus $R$ and element $a : \\alpha$: - $R(R(a)) = R(a)$ (idempotence) - $a \\leq R(a)$ (inflation) - $R(a \\sqcap b) = R(a) \\sqcap R(b)$ (meets preserved) - $R(\\bot) = \\bot$ (bottom preserved)",
      "url": "../web/sec-nucleus.html#lem:nucleus-props"
    },
    {
      "id": "lem:process-ortho",
      "isPlaceholder": false,
      "kind": "lemma",
      "lean": "HeytingLean.LoF.Reentry.process_inf_counter",
      "leanDeps": [
        "HeytingLean.LoF.PrimaryAlgebra",
        "HeytingLean.LoF.Reentry",
        "Eq",
        "HeytingLean.LoF.Reentry.Omega",
        "Min.min",
        "SemilatticeInf.toMin",
        "Sublocale.carrier.instSemilatticeInf",
        "HeytingLean.LoF.PrimaryAlgebra.toFrame",
        "Nucleus.toSublocale",
        "HeytingLean.LoF.Reentry.nucleus",
        "HeytingLean.LoF.Reentry.process",
        "HeytingLean.LoF.Reentry.counterProcess",
        "Bot.bot",
        "OrderBot.toBot",
        "Preorder.toLE",
        "PartialOrder.toPreorder",
        "SemilatticeSup.toPartialOrder",
        "Lattice.toSemilatticeSup",
        "GeneralizedHeytingAlgebra.toLattice",
        "HeytingAlgebra.toGeneralizedHeytingAlgebra",
        "Sublocale.carrier.instHeytingAlgebra",
        "HeytingAlgebra.toOrderBot",
        "LE.le",
        "Subtype.instLE",
        "CompleteSemilatticeInf.toPartialOrder",
        "CompleteLattice.toCompleteSemilatticeInf",
        "Order.Frame.toCompleteLattice",
        "Membership.mem",
        "Sublocale",
        "SetLike.instMembership",
        "Sublocale.instSetLike",
        "id",
        "of_eq_true",
        "Lattice.toSemilatticeInf",
        "ConditionallyCompleteLattice.toLattice",
        "CompleteLattice.toConditionallyCompleteLattice",
        "HeytingLean.LoF.Reentry.primordial",
        "HeytingLean.LoF.Reentry.counter",
        "Subtype.val",
        "Eq.trans",
        "Order.Frame.toHeytingAlgebra",
        "True",
        "congrArg",
        "HeytingLean.LoF.Reentry.orthogonal",
        "bot_le._simp_1",
        "le_antisymm",
        "Subtype.partialOrder",
        "bot_le"
      ],
      "leanDoc": "Process and counter-process are disjoint fixed points in `\u03a9_R`. ",
      "leanFound": true,
      "name": "Process Orthogonality",
      "shape": "ellipse",
      "status": "formalized",
      "summary": "\\leanok The process and counter-process are disjoint: \\[ process \\sqcap counterProcess = \\bot \\]",
      "url": "../web/sec-processes.html#lem:process-ortho"
    },
    {
      "id": "thm:build-contract",
      "isPlaceholder": false,
      "kind": "theorem",
      "lean": null,
      "leanDeps": [],
      "leanDoc": null,
      "leanFound": false,
      "name": "Build Contract",
      "shape": "ellipse",
      "status": "statement-ready",
      "summary": "All verification runs satisfy: verbatim lake build -- -Dno_sorry -DwarningAsError=true verbatim No sorry, admit, or custom axioms permitted.",
      "url": "../web/sec-test-coverage.html#thm:build-contract"
    },
    {
      "id": "thm:clifford-rt",
      "isPlaceholder": false,
      "kind": "theorem",
      "lean": "HeytingLean.Bridges.Clifford.Model.decode_encode",
      "leanDeps": [
        "HeytingLean.LoF.PrimaryAlgebra",
        "HeytingLean.Bridges.Clifford.Model",
        "HeytingLean.LoF.Reentry.Omega",
        "HeytingLean.Bridges.Clifford.Model.R",
        "Eq",
        "HeytingLean.Bridges.Clifford.Model.decode",
        "HeytingLean.Contracts.RoundTrip.encode",
        "HeytingLean.Bridges.Clifford.Model.Carrier",
        "HeytingLean.Bridges.Clifford.Model.contract",
        "id",
        "HeytingLean.Contracts.RoundTrip.round"
      ],
      "leanDoc": null,
      "leanFound": true,
      "name": "Clifford Round-Trip",
      "shape": "ellipse",
      "status": "formalized",
      "summary": "\\leanok Clifford encoding/decoding satisfies the round-trip contract.",
      "url": "../web/sec-clifford-bridge.html#thm:clifford-rt"
    },
    {
      "id": "thm:clifford-stage",
      "isPlaceholder": false,
      "kind": "theorem",
      "lean": "HeytingLean.Bridges.Clifford.Model.stageOrthocomplement_encode",
      "leanDeps": [
        "HeytingLean.LoF.PrimaryAlgebra",
        "HeytingLean.Bridges.Clifford.Model",
        "HeytingLean.LoF.Reentry.Omega",
        "HeytingLean.Bridges.Clifford.Model.R",
        "Eq",
        "HeytingLean.Bridges.Clifford.Model.Carrier",
        "HeytingLean.Bridges.Clifford.Model.stageOrthocomplement",
        "HeytingLean.Contracts.RoundTrip.encode",
        "HeytingLean.Bridges.Clifford.Model.contract",
        "HeytingLean.Bridges.Clifford.Model.encode",
        "HeytingLean.Logic.Stage.DialParam.orthocomplement",
        "HeytingLean.Logic.Modal.DialParam.base",
        "of_eq_true",
        "HImp.himp",
        "HeytingLean.Logic.Modal.Dial.core",
        "HeytingLean.Logic.Modal.DialParam.dial",
        "Sublocale.carrier.instHImp",
        "HeytingLean.LoF.PrimaryAlgebra.toFrame",
        "Nucleus.toSublocale",
        "HeytingLean.LoF.Reentry.nucleus",
        "HeytingLean.Bridges.Clifford.Model.decode",
        "Bot.bot",
        "OrderBot.toBot",
        "Preorder.toLE",
        "PartialOrder.toPreorder",
        "SemilatticeSup.toPartialOrder",
        "Lattice.toSemilatticeSup",
        "GeneralizedHeytingAlgebra.toLattice",
        "HeytingAlgebra.toGeneralizedHeytingAlgebra",
        "HeytingLean.LoF.Reentry.instHeytingOmega",
        "HeytingAlgebra.toOrderBot",
        "GeneralizedHeytingAlgebra.toHImp",
        "Eq.trans",
        "HasCompl.compl",
        "HeytingAlgebra.toHasCompl",
        "True",
        "congr",
        "congrArg",
        "HeytingLean.Bridges.Clifford.Model.decode_encode",
        "himp_bot",
        "eq_self"
      ],
      "leanDoc": null,
      "leanFound": true,
      "name": "Clifford Stage Transport",
      "shape": "ellipse",
      "status": "formalized",
      "summary": "\\leanok Orthocomplementation commutes with Clifford encoding.",
      "url": "../web/sec-clifford-bridge.html#thm:clifford-stage"
    },
    {
      "id": "thm:double-neg",
      "isPlaceholder": false,
      "kind": "theorem",
      "lean": "HeytingLean.LoF.Reentry.double_neg",
      "leanDeps": [
        "HeytingLean.LoF.PrimaryAlgebra",
        "HeytingLean.LoF.Reentry",
        "HeytingLean.LoF.Reentry.Omega",
        "LE.le",
        "Subtype.instLE",
        "Preorder.toLE",
        "PartialOrder.toPreorder",
        "CompleteSemilatticeInf.toPartialOrder",
        "CompleteLattice.toCompleteSemilatticeInf",
        "Order.Frame.toCompleteLattice",
        "HeytingLean.LoF.PrimaryAlgebra.toFrame",
        "Membership.mem",
        "Sublocale",
        "SetLike.instMembership",
        "Sublocale.instSetLike",
        "Nucleus.toSublocale",
        "HeytingLean.LoF.Reentry.nucleus",
        "HImp.himp",
        "Sublocale.carrier.instHImp",
        "Bot.bot",
        "OrderBot.toBot",
        "SemilatticeSup.toPartialOrder",
        "Lattice.toSemilatticeSup",
        "GeneralizedHeytingAlgebra.toLattice",
        "HeytingAlgebra.toGeneralizedHeytingAlgebra",
        "HeytingLean.LoF.Reentry.instHeytingOmega",
        "HeytingAlgebra.toOrderBot",
        "le_rfl",
        "Subtype.preorder",
        "Min.min",
        "SemilatticeInf.toMin",
        "Sublocale.carrier.instSemilatticeInf",
        "Iff.mpr",
        "HeytingLean.LoF.Reentry.heyting_adjunction",
        "Eq.mpr",
        "eq_of_heq",
        "LE",
        "Eq",
        "Eq.casesOn",
        "HEq",
        "Eq.ndrec",
        "Eq.refl",
        "HEq.refl",
        "Eq.symm",
        "of_eq_true",
        "GeneralizedHeytingAlgebra.toHImp",
        "Eq.trans",
        "True",
        "congr",
        "congrArg",
        "HasCompl.compl",
        "HeytingAlgebra.toHasCompl",
        "himp_bot",
        "inf_compl_self",
        "inf_comm",
        "eq_self",
        "Iff.mp"
      ],
      "leanDoc": null,
      "leanFound": true,
      "name": "Double Negation",
      "shape": "ellipse",
      "status": "formalized",
      "summary": "\\leanok For all $a \\in \\Omega_R$: \\[ a \\leq ((a \\Rightarrow \\bot) \\Rightarrow \\bot) \\]",
      "url": "../web/sec-heyting-core.html#thm:double-neg"
    },
    {
      "id": "thm:euler-eq-process",
      "isPlaceholder": false,
      "kind": "theorem",
      "lean": "HeytingLean.LoF.Reentry.eulerBoundary_eq_process",
      "leanDeps": [
        "HeytingLean.LoF.PrimaryAlgebra",
        "HeytingLean.LoF.Reentry",
        "Eq",
        "HeytingLean.LoF.Reentry.Omega",
        "HeytingLean.LoF.Reentry.eulerBoundary",
        "HeytingLean.LoF.Reentry.process",
        "le_antisymm",
        "Subtype.partialOrder",
        "CompleteSemilatticeInf.toPartialOrder",
        "CompleteLattice.toCompleteSemilatticeInf",
        "Order.Frame.toCompleteLattice",
        "HeytingLean.LoF.PrimaryAlgebra.toFrame",
        "Membership.mem",
        "Sublocale",
        "SetLike.instMembership",
        "Sublocale.instSetLike",
        "Nucleus.toSublocale",
        "HeytingLean.LoF.Reentry.nucleus",
        "HeytingLean.LoF.Reentry.eulerBoundary_le_process",
        "HeytingLean.LoF.Reentry.process_le_eulerBoundary"
      ],
      "leanDoc": null,
      "leanFound": true,
      "name": "Euler Boundary Equals Process",
      "shape": "ellipse",
      "status": "formalized",
      "summary": "\\leanok The Euler boundary coincides with the primordial process: \\[ eulerBoundary = process \\]",
      "url": "../web/sec-euler-boundary.html#thm:euler-eq-process"
    },
    {
      "id": "thm:graph-rt",
      "isPlaceholder": false,
      "kind": "theorem",
      "lean": "HeytingLean.Bridges.Graph.Model.decode_encode",
      "leanDeps": [
        "HeytingLean.LoF.PrimaryAlgebra",
        "HeytingLean.Bridges.Graph.Model",
        "HeytingLean.LoF.Reentry.Omega",
        "HeytingLean.Bridges.Graph.Model.R",
        "Eq",
        "HeytingLean.Bridges.Graph.Model.decode",
        "HeytingLean.Contracts.RoundTrip.encode",
        "HeytingLean.Bridges.Graph.Model.Carrier",
        "HeytingLean.Bridges.Graph.Model.contract",
        "id",
        "HeytingLean.Contracts.RoundTrip.round"
      ],
      "leanDoc": null,
      "leanFound": true,
      "name": "Graph Round-Trip",
      "shape": "ellipse",
      "status": "formalized",
      "summary": "\\leanok Graph encoding/decoding forms a round-trip pair.",
      "url": "../web/sec-graph-bridge.html#thm:graph-rt"
    },
    {
      "id": "thm:graph-stage",
      "isPlaceholder": false,
      "kind": "theorem",
      "lean": "HeytingLean.Bridges.Graph.Model.stageEffectAdd_encode",
      "leanDeps": [
        "HeytingLean.LoF.PrimaryAlgebra",
        "HeytingLean.Bridges.Graph.Model",
        "HeytingLean.LoF.Reentry.Omega",
        "HeytingLean.Bridges.Graph.Model.R",
        "Eq",
        "Option",
        "HeytingLean.Bridges.Graph.Model.Carrier",
        "HeytingLean.Bridges.Graph.Model.stageEffectAdd?",
        "HeytingLean.Contracts.RoundTrip.encode",
        "HeytingLean.Bridges.Graph.Model.contract",
        "Option.map",
        "HeytingLean.Bridges.Graph.Model.encode",
        "HeytingLean.Logic.Stage.DialParam.effectAdd?",
        "HeytingLean.Logic.Modal.DialParam.base",
        "of_eq_true",
        "HeytingLean.Bridges.Graph.Model.decode",
        "Eq.trans",
        "True",
        "congrArg",
        "congr",
        "HeytingLean.Logic.Modal.Dial.core",
        "HeytingLean.Logic.Modal.DialParam.dial",
        "HeytingLean.Bridges.Graph.Model.decode_encode",
        "eq_self"
      ],
      "leanDoc": null,
      "leanFound": true,
      "name": "Graph Stage Transport",
      "shape": "ellipse",
      "status": "formalized",
      "summary": "\\leanok Effect algebra operations transport through the graph bridge.",
      "url": "../web/sec-graph-bridge.html#thm:graph-stage"
    },
    {
      "id": "thm:heyting-adjunction",
      "isPlaceholder": false,
      "kind": "theorem",
      "lean": "HeytingLean.LoF.Reentry.heyting_adjunction",
      "leanDeps": [
        "HeytingLean.LoF.PrimaryAlgebra",
        "HeytingLean.LoF.Reentry",
        "HeytingLean.LoF.Reentry.Omega",
        "Iff",
        "LE.le",
        "Subtype.instLE",
        "Preorder.toLE",
        "PartialOrder.toPreorder",
        "CompleteSemilatticeInf.toPartialOrder",
        "CompleteLattice.toCompleteSemilatticeInf",
        "Order.Frame.toCompleteLattice",
        "HeytingLean.LoF.PrimaryAlgebra.toFrame",
        "Membership.mem",
        "Sublocale",
        "SetLike.instMembership",
        "Sublocale.instSetLike",
        "Nucleus.toSublocale",
        "HeytingLean.LoF.Reentry.nucleus",
        "Min.min",
        "SemilatticeInf.toMin",
        "Sublocale.carrier.instSemilatticeInf",
        "HImp.himp",
        "Sublocale.carrier.instHImp",
        "Iff.symm",
        "SemilatticeInf.toPartialOrder",
        "Lattice.toSemilatticeInf",
        "GeneralizedHeytingAlgebra.toLattice",
        "HeytingAlgebra.toGeneralizedHeytingAlgebra",
        "HeytingLean.LoF.Reentry.instHeytingOmega",
        "GeneralizedHeytingAlgebra.toHImp",
        "le_himp_iff"
      ],
      "leanDoc": null,
      "leanFound": true,
      "name": "Heyting Adjunction",
      "shape": "ellipse",
      "status": "formalized",
      "summary": "\\leanok For all $a, b, c \\in \\Omega_R$: \\[ a \\sqcap b \\leq c \\iff a \\leq b \\Rightarrow c \\]",
      "url": "../web/sec-heyting-core.html#thm:heyting-adjunction"
    },
    {
      "id": "thm:heyting-instance",
      "isPlaceholder": false,
      "kind": "theorem",
      "lean": "HeytingLean.LoF.Reentry.instHeytingOmega",
      "leanDeps": [
        "HeytingLean.LoF.PrimaryAlgebra",
        "HeytingLean.LoF.Reentry",
        "HeytingAlgebra",
        "HeytingLean.LoF.Reentry.Omega",
        "inferInstance",
        "Sublocale.carrier.instHeytingAlgebra",
        "HeytingLean.LoF.PrimaryAlgebra.toFrame",
        "Nucleus.toSublocale",
        "HeytingLean.LoF.Reentry.nucleus"
      ],
      "leanDoc": null,
      "leanFound": true,
      "name": "Heyting Algebra Structure",
      "shape": "ellipse",
      "status": "formalized",
      "summary": "\\leanok $\\Omega_R$ inherits a Heyting algebra structure with: - Meet: $a \\sqcap b$ (inherited from $\\alpha$) - Heyting implication: $a \\Rightarrow b$ satisfying residuation",
      "url": "../web/sec-heyting-core.html#thm:heyting-instance"
    },
    {
      "id": "thm:tensor-rt",
      "isPlaceholder": false,
      "kind": "theorem",
      "lean": "HeytingLean.Bridges.Tensor.Model.decode_encode",
      "leanDeps": [
        "HeytingLean.LoF.PrimaryAlgebra",
        "HeytingLean.Bridges.Tensor.Model",
        "HeytingLean.LoF.Reentry.Omega",
        "HeytingLean.Bridges.Tensor.Model.R",
        "Eq",
        "HeytingLean.Bridges.Tensor.Model.decode",
        "HeytingLean.Contracts.RoundTrip.encode",
        "HeytingLean.Bridges.Tensor.Model.Carrier",
        "HeytingLean.Bridges.Tensor.Model.contract",
        "id",
        "HeytingLean.Contracts.RoundTrip.round"
      ],
      "leanDoc": null,
      "leanFound": true,
      "name": "Tensor Round-Trip",
      "shape": "ellipse",
      "status": "formalized",
      "summary": "\\leanok Encoding followed by decoding recovers the original state (up to canonical isomorphism).",
      "url": "../web/sec-tensor-bridge.html#thm:tensor-rt"
    },
    {
      "id": "thm:tensor-stage",
      "isPlaceholder": false,
      "kind": "theorem",
      "lean": "HeytingLean.Bridges.Tensor.Model.stageMvAdd_encode",
      "leanDeps": [
        "HeytingLean.LoF.PrimaryAlgebra",
        "HeytingLean.Bridges.Tensor.Model",
        "HeytingLean.LoF.Reentry.Omega",
        "HeytingLean.Bridges.Tensor.Model.R",
        "Eq",
        "HeytingLean.Bridges.Tensor.Model.Carrier",
        "HeytingLean.Bridges.Tensor.Model.stageMvAdd",
        "HeytingLean.Contracts.RoundTrip.encode",
        "HeytingLean.Bridges.Tensor.Model.contract",
        "HeytingLean.Bridges.Tensor.Model.encode",
        "HeytingLean.Logic.Stage.DialParam.mvAdd",
        "HeytingLean.Logic.Modal.DialParam.base",
        "of_eq_true",
        "Max.max",
        "HeytingLean.Logic.Modal.Dial.core",
        "HeytingLean.Logic.Modal.DialParam.dial",
        "SemilatticeSup.toMax",
        "Lattice.toSemilatticeSup",
        "ConditionallyCompleteLattice.toLattice",
        "CompleteLattice.toConditionallyCompleteLattice",
        "Sublocale.carrier.instCompleteLattice",
        "HeytingLean.LoF.PrimaryAlgebra.toFrame",
        "Nucleus.toSublocale",
        "HeytingLean.LoF.Reentry.nucleus",
        "HeytingLean.Bridges.Tensor.Model.decode",
        "Eq.trans",
        "True",
        "congrArg",
        "congr",
        "HeytingLean.Bridges.Tensor.Model.decode_encode",
        "eq_self"
      ],
      "leanDoc": null,
      "leanFound": true,
      "name": "Tensor Stage Transport",
      "shape": "ellipse",
      "status": "formalized",
      "summary": "\\leanok MV-algebra addition commutes with tensor encoding: \\[ encode(mvAdd(a, b)) = mvAdd(encode(a), encode(b)) \\]",
      "url": "../web/sec-tensor-bridge.html#thm:tensor-stage"
    }
  ]
};
