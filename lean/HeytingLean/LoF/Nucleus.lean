import Mathlib.Order.Nucleus
import Mathlib.Order.Sublocale
import HeytingLean.LoF.PrimaryAlgebra

open scoped Classical

namespace HeytingLean
namespace LoF

/-- `Reentry α` packages the re-entry operation as a nucleus on a primary algebra together with
the minimal pair of complementary fixed points generated by the primordial distinction. -/
structure Reentry (α : Type u) [PrimaryAlgebra α] where
  nucleus : Nucleus α
  primordial : α
  counter : α
  primordial_mem : nucleus primordial = primordial
  counter_mem : nucleus counter = counter
  primordial_nonbot : ⊥ < primordial
  counter_nonbot : ⊥ < counter
  orthogonal : primordial ⊓ counter = ⊥
  primordial_minimal :
    ∀ ⦃x : α⦄, nucleus x = x → ⊥ < x → primordial ≤ x

namespace Reentry

variable {α : Type u} [PrimaryAlgebra α]

instance : CoeFun (Reentry α) (fun _ => α → α) where
  coe R := R.nucleus

@[simp] lemma coe_nucleus (R : Reentry α) : (R.nucleus : α → α) = R := rfl

@[simp] lemma idempotent (R : Reentry α) (a : α) : R (R a) = R a :=
  R.nucleus.idempotent _

@[simp] lemma le_apply (R : Reentry α) (a : α) : a ≤ R a :=
  Nucleus.le_apply (n := R.nucleus) (x := a)

lemma map_inf (R : Reentry α) (a b : α) : R (a ⊓ b) = R a ⊓ R b :=
  Nucleus.map_inf (n := R.nucleus) (x := a) (y := b)

lemma map_sup (R : Reentry α) (a b : α) :
    R (a ⊔ b) = R ((R a) ⊔ (R b)) := by
  classical
  simpa [Reentry.coe_nucleus] using
    (R.nucleus.toClosureOperator.closure_sup_closure (x := a) (y := b)).symm

lemma map_sup_le (R : Reentry α) (a b : α) :
    R a ⊔ R b ≤ R (a ⊔ b) := by
  classical
  exact R.nucleus.toClosureOperator.closure_sup_closure_le (x := a) (y := b)

lemma map_himp_le (R : Reentry α) (a b : α) :
    R (a ⇨ b) ≤ a ⇨ R b := by
  simpa [Reentry.coe_nucleus] using
    R.nucleus.map_himp_le (x := a) (y := b)

@[simp] lemma map_himp_apply (R : Reentry α) (a b : α) :
    R (a ⇨ R b) = a ⇨ R b := by
  simpa [Reentry.coe_nucleus] using
    R.nucleus.map_himp_apply (x := a) (y := b)

@[simp] lemma map_bot (R : Reentry α) : R (⊥ : α) = (⊥ : α) := by
  classical
  by_contra hne
  have hlt : (⊥ : α) < R (⊥ : α) :=
    lt_of_le_of_ne bot_le (by
      intro h
      exact hne h.symm)
  have hprim : R.primordial ≤ R (⊥ : α) :=
    R.primordial_minimal (R.idempotent _) hlt
  have hcounter : R (⊥ : α) ≤ R.counter := by
    have hmap := R.map_inf (a := (⊥ : α)) (b := R.counter)
    have hmap' : R (⊥ : α) = R (⊥ : α) ⊓ R.counter :=
      by simpa [inf_bot_eq, R.counter_mem] using hmap
    have hle : R (⊥ : α) ⊓ R.counter ≤ R.counter := inf_le_right
    simpa [hmap'.symm] using hle
  have hprim_le_counter : R.primordial ≤ R.counter := hprim.trans hcounter
  have hpc : R.primordial ⊓ R.counter = R.primordial :=
    inf_eq_left.mpr hprim_le_counter
  have horth : R.primordial = (⊥ : α) := by
    simpa [hpc] using R.orthogonal
  exact (ne_of_gt R.primordial_nonbot) horth

@[simp] lemma monotone (R : Reentry α) : Monotone R :=
  R.nucleus.monotone

/-- Fixed points of the nucleus viewed as the associated sublocale `Ω_R`. -/
abbrev Omega (R : Reentry α) : Type u := R.nucleus.toSublocale

@[simp] lemma primordial_apply (R : Reentry α) :
    R R.primordial = R.primordial :=
  R.primordial_mem

@[simp] lemma counter_apply (R : Reentry α) :
    R R.counter = R.counter :=
  R.counter_mem

lemma primordial_le_of_fixed (R : Reentry α) {x : α}
    (hx_fix : R x = x) (hx_pos : ⊥ < x) :
    R.primordial ≤ x :=
  R.primordial_minimal hx_fix hx_pos

namespace Omega

variable (R : Reentry α)

/-- Build an element of the fixed-point sublocale from an ambient element and a fixpoint proof. -/
def mk (a : α) (h : R a = a) :
    R.Omega := ⟨a, ⟨a, h⟩⟩

@[simp] lemma coe_mk (a : α) (h : R a = a) :
    ((Omega.mk (R := R) a h : R.Omega) : α) = a := rfl

@[simp] lemma apply_coe (a : R.Omega) : R (a : α) = a := by
  obtain ⟨x, hx⟩ := a.property
  have hx₁ : R (a : α) = R (R x) := congrArg R hx.symm
  have hx₂ : R (R x) = R x := R.idempotent x
  exact hx₁.trans (hx₂.trans hx)

@[simp] lemma apply_mk (a : α) (h : R a = a) :
    R ((Omega.mk (R := R) a h : R.Omega) : α) = Omega.mk (R := R) a h := by
  simpa using (apply_coe (R := R) (a := Omega.mk (R := R) a h))

end Omega

/-- The primordial fixed point as an inhabitant of `Ω_R`. -/
def process (R : Reentry α) : R.Omega :=
  Omega.mk (R := R) R.primordial R.primordial_mem

/-- The complementary fixed point capturing the counter-process. -/
def counterProcess (R : Reentry α) : R.Omega :=
  Omega.mk (R := R) R.counter R.counter_mem

@[simp] lemma process_coe (R : Reentry α) :
    ((R.process : R.Omega) : α) = R.primordial := rfl

@[simp] lemma counterProcess_coe (R : Reentry α) :
    ((R.counterProcess : R.Omega) : α) = R.counter := rfl

/-- The primordial process dominates any nontrivial fixed point in the core. -/
lemma process_le_of_pos (R : Reentry α) {x : R.Omega}
    (hx : ⊥ < (x : α)) : R.process ≤ x := by
  change R.primordial ≤ (x : α)
  have hx_fix := Omega.apply_coe (R := R) (a := x)
  exact R.primordial_minimal hx_fix hx

/-- Process and counter-process are disjoint fixed points in `Ω_R`. -/
lemma process_inf_counter (R : Reentry α) :
    R.process ⊓ R.counterProcess = ⊥ := by
  have h_le : R.process ⊓ R.counterProcess ≤ ⊥ := by
    change ((R.process ⊓ R.counterProcess : R.Omega) : α)
        ≤ ((⊥ : R.Omega) : α)
    simp [process, counterProcess, R.orthogonal]
  exact le_antisymm h_le bot_le

/-- The primordial fixed point lies strictly above the boundary. -/
lemma process_pos (R : Reentry α) : ⊥ < ((R.process : R.Omega) : α) := by
  change ⊥ < R.primordial
  exact R.primordial_nonbot

/-- The counter-process fixed point lies strictly above the boundary. -/
lemma counter_pos (R : Reentry α) : ⊥ < ((R.counterProcess : R.Omega) : α) := by
  change ⊥ < R.counter
  exact R.counter_nonbot

/-- Package the complementary fixed points generated by re-entry. -/
def complementaryPair (R : Reentry α) : R.Omega × R.Omega :=
  ⟨R.process, R.counterProcess⟩

@[simp] lemma complementaryPair_fst (R : Reentry α) :
    (R.complementaryPair.fst : α) = R.primordial := rfl

@[simp] lemma complementaryPair_snd (R : Reentry α) :
    (R.complementaryPair.snd : α) = R.counter := rfl

@[simp] lemma complementaryPair_inf (R : Reentry α) :
    R.complementaryPair.fst ⊓ R.complementaryPair.snd = ⊥ :=
  R.process_inf_counter

/-- Candidates for the Euler boundary: fixed points strictly above the boundary element. -/
def boundaryCandidates (R : Reentry α) : Set (R.Omega) :=
  {x | ⊥ < (x : α)}

@[simp] lemma mem_boundaryCandidates (R : Reentry α) (x : R.Omega) :
    x ∈ R.boundaryCandidates ↔ ⊥ < (x : α) := Iff.rfl

lemma process_mem_boundaryCandidates (R : Reentry α) :
    R.process ∈ R.boundaryCandidates := by
  simpa [boundaryCandidates] using R.process_pos

lemma counter_mem_boundaryCandidates (R : Reentry α) :
    R.counterProcess ∈ R.boundaryCandidates := by
  simpa [boundaryCandidates] using R.counter_pos

/-- The Euler boundary is the infimum of all nontrivial fixed points. -/
noncomputable def eulerBoundary (R : Reentry α) : R.Omega :=
  sInf (R.boundaryCandidates)

lemma eulerBoundary_def (R : Reentry α) :
    R.eulerBoundary = sInf (R.boundaryCandidates) := rfl

lemma eulerBoundary_le_of_pos (R : Reentry α) {x : R.Omega}
    (hx : ⊥ < (x : α)) : R.eulerBoundary ≤ x := by
  have hx' : x ∈ R.boundaryCandidates := by simpa [boundaryCandidates] using hx
  simpa [eulerBoundary_def] using sInf_le (a := x) hx'

lemma le_of_lower_bound (R : Reentry α) {a : R.Omega}
    (h : ∀ ⦃x⦄, x ∈ R.boundaryCandidates → a ≤ x) :
    a ≤ R.eulerBoundary := by
  classical
  refine le_sInf ?_
  intro x hx
  exact h hx

lemma eulerBoundary_le_process (R : Reentry α) :
    R.eulerBoundary ≤ R.process :=
  R.eulerBoundary_le_of_pos R.process_pos

lemma process_le_eulerBoundary (R : Reentry α) :
    R.process ≤ R.eulerBoundary := by
  refine R.le_of_lower_bound ?_
  intro x hx
  have hx' : ⊥ < (x : α) := by simpa [boundaryCandidates] using hx
  exact R.process_le_of_pos hx'

@[simp] lemma eulerBoundary_eq_process (R : Reentry α) :
    R.eulerBoundary = R.process :=
  le_antisymm (R.eulerBoundary_le_process) (R.process_le_eulerBoundary)

lemma eulerBoundary_pos (R : Reentry α) :
    ⊥ < ((R.eulerBoundary : R.Omega) : α) := by
  simpa [eulerBoundary_eq_process] using (process_pos (R := R))

lemma eulerBoundary_mem_candidates (R : Reentry α) :
    R.eulerBoundary ∈ R.boundaryCandidates := by
  simpa [boundaryCandidates] using R.eulerBoundary_pos

lemma eulerBoundary_le_of_candidate (R : Reentry α) {x : R.Omega}
    (hx : x ∈ R.boundaryCandidates) : R.eulerBoundary ≤ x :=
  R.eulerBoundary_le_of_pos (by simpa [boundaryCandidates] using hx)

lemma eulerBoundary_le_counter (R : Reentry α) :
    R.eulerBoundary ≤ R.counterProcess :=
  R.eulerBoundary_le_of_pos R.counter_pos

@[simp] lemma complementaryPair_fst_euler (R : Reentry α) :
    R.complementaryPair.fst = R.eulerBoundary := by
  ext
  simp [complementaryPair, process, eulerBoundary_eq_process]

lemma eulerBoundary_complementary (R : Reentry α) :
    R.eulerBoundary ⊓ R.counterProcess = ⊥ := by
  calc
    R.eulerBoundary ⊓ R.counterProcess
        = R.process ⊓ R.counterProcess := by
          simp [eulerBoundary_eq_process]
    _ = ⊥ := R.process_inf_counter

end Reentry

end LoF
end HeytingLean
