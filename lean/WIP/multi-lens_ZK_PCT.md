Multi-lens proof-carrying transactions (ML-PCT) will sit on top of the nucleus-driven Heyting core and the transport infrastructure we already maintain under `lean/HeytingLean`. This document replaces the earlier ad‚Äëhoc sketch with a Lean-first plan that matches the codebase, keeps proofs inside the existing build (`lake build -- -Dno_sorry -DwarningAsError=true`), and produces cryptographically consumable outputs (canonical traces and R1CS exports).

---

# 1‚ÄØ‚ÄØCurrent Baseline

* **Core logic.** `HeytingLean/LoF` models the nucleus `R`, the fixed-point core `Œ©_R`, and the stage semantics we already use for the bridge suite.
* **Lenses & transport.** `HeytingLean/Bridges` and `HeytingLean/Contracts` implement tensor, graph (Alexandroff), and Clifford lenses together with verified RT/TRI contracts. `HeytingLean/Runtime/BridgeSuite` exposes the multi-lens runtime entry point.
* **Proof widgets.** `HeytingLean/ProofWidgets` and the Law-of-Form blueprint give us graph visualisation, certified transports, and finite-model sanity checks.
* **Tooling.** `Docs/LoFBlueprint` (regenerated with `./tools/package_blueprint.sh`) tracks every Lean declaration; `lake build -- -Dno_sorry -DwarningAsError=true` is our CI target.

This plan assumes nothing beyond the current repo and keeps all new code under `lean/HeytingLean/Crypto` unless otherwise stated.

---

# 2‚ÄØ‚ÄØTarget Outcome

Verified-by-construction Multi-Lens ZK + Proof-Carrying Transactions with:

1. A shared **logical IR** interpreted in `Œ©_R` and transported to every lens.
2. A **certified VM** + compiler per lens that preserve core semantics (RT/TRI aware).
3. A **witness relation** and proof objects whose soundness/completeness are proved in Lean.
4. A Boolean-lens lowering to **R1CS** plus JSON exporters so third-party provers can consume the circuit.
5. Executable entry points (`pct_prove`, `pct_verify`, `pct_r1cs`) generated by `lake exe` that inherit the theorems.

---

# Progress Snapshot

- ‚úÖ Phase‚ÄØA ‚Äì Logical IR (`Crypto/Form`, `Crypto/CoreSemantics`).
- ‚úÖ Phase‚ÄØB ‚Äì Lens abstraction & transport (`Crypto/Lens/*`).
- ‚úÖ Phase‚ÄØC ‚Äì Postfix VM, compiler, and correctness (`Crypto/Prog`, `Crypto/VM`, `Crypto/Compile`, `Crypto/Correctness`).
- ‚úÖ Phase‚ÄØD ‚Äì Witness relation & PCT payload (`Crypto/Witness`, `Crypto/PCT`).
- ‚úÖ Phase‚ÄØE1 ‚Äì Boolean VM specialisation with canonical traces (`Crypto/BoolLens`).
- üü° Phase‚ÄØE2 ‚Äì Boolean arithmetisation & R1CS scaffolding (`Crypto/ZK/BoolArith`, `Crypto/ZK/R1CS`, `Crypto/ZK/R1CSBool`).  
  _Current status:_  
  ‚Ä¢ Canonical BoolLens trace/value available (`Crypto/BoolLens`).  
  ‚Ä¢ Support-oriented utilities factored out (`Crypto/ZK/Support`) giving `AgreesOn`, `support`, and `System.satisfied_ext` lemmas (ready for use).  
  ‚Ä¢ Boolean builder still uses the original lightweight invariant (`Matches`/`Bounded`); support/satisfaction strengthening staged to land next.  
  ‚Ä¢ R1CS compiler emits witness/constraints for all opcodes (no global proof yet).  
  ‚Ä¢ Added a stable `System.satisfied_cons` shim and fresh local helper lemmas (support subsets, boolean closures, head satisfaction bridges) preparing the strong opcode proofs.  
  ‚Ä¢ `applyAnd_strong` now refactored to the new 3-step structure; remaining opcodes still pending.  
  ‚Ä¢ Initial attempt to add the Prop-shaped support/boolean-closure helpers and refactor `applyAnd_strong` caused compile issues; changes were reverted‚Äînext retry should stage helpers incrementally with dedicated tests.  
  _Next steps:_  
  1. Introduce a strengthened `StrongInvariant` (tracks `SupportOK`/`Satisfied`) alongside the existing invariant and prove a dedicated `pushConst_strong`.  
  2. Bridge `StrongInvariant` back to the old invariant (`Invariant_of_strong` helper) so existing lemmas continue to compile while we migrate.  
  3. Reprove opcode preservation (`applyAnd`/`applyOr`/`applyImp`) under the strong invariant using the new support lemmas.  
  4. Induct over `compileSteps` with the strong invariant to show the final builder satisfies support/satisfaction obligations.  
  5. Establish `soundness`: compiled `(system, assignment)` satisfies every constraint and output matches `BoolLens.eval`.  
  6. Establish `completeness`: canonical trace provides a satisfying assignment.  
  7. Expose the Boolean witness/output to the CLI layer once proofs land.
- ‚è≥ Phase‚ÄØE3 ‚Äì CLI executables and regression tests (not started).

Current focus: carry the Boolean stack invariant through `applyAnd`/`applyOr`/`applyImp`, then lift it to `compileSteps` to obtain full R1CS soundness/completeness before wiring the witness into the CLI.

---

# 3‚ÄØ‚ÄØDelivery Plan

## Phase A ‚Äì Logical IR and Core Semantics ‚úÖ

- [x] `HeytingLean/Crypto/Form.lean` ‚Äì inductive IR over `Fin n` variables with Heyting connectives.
- [x] `HeytingLean/Crypto/CoreSemantics.lean` ‚Äì environment alias and `Form.evalŒ©` lemmas (`evalŒ©_and`, `evalŒ©_imp`, ‚Ä¶).

Deliverable status: ‚úÖ `Form.evalŒ©` proved and in CI.

## Phase B ‚Äì Lens Semantics & Transport ‚úÖ

- [x] `HeytingLean/Crypto/Lens/Class.lean` ‚Äì reusable `Lens` structure with lift helpers (`enc`, `dec`, `logicalShadow`, stack-friendly ops).
- [x] `HeytingLean/Crypto/Lens/Semantics.lean` ‚Äì lens-side environments and `Form.evalL`.
- [x] `HeytingLean/Crypto/Lens/Transport.lean` ‚Äì transport lemma `dec (evalL _ (enc ‚àò œÅ)) = evalŒ© _ œÅ`.

Deliverable status: ‚úÖ transport soundness available for any `Lens`.

## Phase C ‚Äì Certified Program Representation ‚úÖ

- [x] `HeytingLean/Crypto/Prog.lean` ‚Äì postfix instruction set (`Instr`, `Program`).
- [x] `HeytingLean/Crypto/VM.lean` ‚Äì stack machine with traces (`run`, `traceFrom`, lemmas like `exec_append`).
- [x] `HeytingLean/Crypto/Compile.lean` ‚Äì structural compiler and lemmas (`exec_compile_aux`, `run_compile_value`).
- [x] `HeytingLean/Crypto/Correctness.lean` ‚Äì canonical run/value helpers and theorem `compile_correct`.

Deliverable status: ‚úÖ `compile_correct` ready for downstream lenses.

## Phase D ‚Äì Witness Relation & Proof-Carrying Transactions ‚úÖ

- [x] `HeytingLean/Crypto/Witness.lean` ‚Äì canonical witness trace & relation, soundness/completeness lemmas.
- [x] `HeytingLean/Crypto/PCT.lean` ‚Äì payload structure, verification predicate, completeness witness.
- [ ] Executables (`Exec/pct_prove`, `Exec/pct_verify`) ‚Äì pending (see Phase‚ÄØE3).

Deliverable status: ‚úÖ proof-carrying payload in Lean; CLI generation outstanding.

## Phase E ‚Äì Zero-Knowledge Lowering (Boolean Lens) ‚Äì In Progress

- ‚úÖ **E1 ‚Äì Boolean VM specialisation (`HeytingLean/Crypto/BoolLens.lean`).**
  - Standalone Boolean evaluator (`eval`) and stack VM mirroring the generic pipeline.
  - Canonical `Trace`/`Value` helpers with lemma `canonicalValue_eq_eval`.
- üü° **E2 ‚Äì R1CS backend.**
- ‚úÖ Boolean-to-field lemmas (`HeytingLean/Crypto/ZK/BoolArith`), minimal R1CS primitives (`HeytingLean/Crypto/ZK/R1CS`), and an initial compiler plus stack invariants (`HeytingLean/Crypto/ZK/R1CSBool` ‚Äì `pushConst` case proven).
- ‚è≥ Extend invariants to `applyAnd`/`applyOr`/`applyImp`, then prove the generated R1CS instance is sound/complete w.r.t. `BoolLens`, surfacing the witness/output to the CLI layer.
- ‚è≥ **E3 ‚Äì Exporters.**
  - TODO: `Exec/pct_r1cs.lean`, JSON wiring, optional SNARK hand-off.

Deliverable: SNARK-friendly artefacts (pending).

## Phase F ‚Äì Testing & Tooling

1. **Deterministic finite models (`HeytingLean/Crypto/Models.lean`).**
   * Use the existing Alexandroff and tensor sample models for #eval regression tests.
2. **Test harness (`lean/Tests/CryptoSuite.lean`).**
   * Import all theorems, run sample forms through every lens.
3. **Blueprint updates.**
   * Document the new declarations in `Docs/LoFBlueprint` (the packaging script does the heavy lifting).
   * Add a short operator‚Äôs guide in `Docs/CryptoStack.md`.

Deliverable: a repeatable test suite invoked by `lake build` and CI.

---

# 4‚ÄØ‚ÄØBuild & Integration Checklist

1. **Lean build:** `cd lean && lake build -- -Dno_sorry -DwarningAsError=true`. ‚úÖ
2. **Blueprint regeneration:** `cd blueprint && ./tools/package_blueprint.sh`.
3. **Executables:**
   * `lake exe pct_prove form.json env.json`. ‚è≥
   * `lake exe pct_verify form.json env.json trace.json`. ‚è≥
   * `lake exe pct_r1cs form.json env.json`. ‚è≥
4. **Optional SNARK test:** feed the generated `r1cs.json` + `assignment.json` into an external prover (outside the Lean repo).

---

# 5‚ÄØ‚ÄØSuccess Criteria

- ‚úÖ All new Lean files compile with zero `sorry` under the existing CI settings.
- ‚úÖ `transport_sound` holds for every registered lens (tensor, graph, Clifford, Boolean via `BoolLens` semantics).
- ‚úÖ VM correctness theorem (`compile_correct`) is in `HeytingLean.Crypto`.
- ‚è≥ PCT executables round-trip deterministic traces and align with the Lean proof.
- ‚è≥ Boolean lowering produces R1CS artefacts whose satisfaction proof is checked in Lean.

This plan keeps us aligned with the current codebase, leverages the bridge suite that already runs inside `lake env`, and yields cryptographically consumable artefacts backed by machine-checked proofs.

* `def compile : Form ‚Üí Prog` (postfix codegen).
* Lemma `compile_evalL`: `evalL L œÜ œÅ = (run L (compile œÜ) œÅ).snd`
  (induction on `œÜ`; VM aligns with evalL by construction).

**Cert/Correctness.lean**

* Combine `compile_evalL` with `transport_sound`:

```lean
theorem compile_correct (L) :
  ‚àÄ œÜ œÅ, L.dec (Prod.snd (run L (compile œÜ) (L.enc ‚àò œÅ)))
      = evalŒ© œÜ œÅ
```

This is the **central theorem** that makes the binaries proof-carrying by construction.

**Cert/Witness.lean**

* `def W_L (L) (œÜ œÅ t) : Prop := t = (run L (compile œÜ) (L.enc ‚àò œÅ)).fst`
* **Soundness:** `W_L L œÜ œÅ t ‚Üí L.dec (out t) = evalŒ© œÜ œÅ`
* **Completeness:** `‚àÉ t, W_L L œÜ œÅ t`

---

## 4) Boolean-lens R1CS (ZK-ready)

Start with the **Bool lens** (`Int = id`, values in {0,1}), which arithmetizes cleanly.

**ZK/BoolArith.lean**

* Boolean constraints: `b*(b-1)=0`
* Gates:

  * `z_and = x*y`
  * `z_or  = x + y - x*y`
  * `z_not = 1 - x`
  * `z_impl = 1 - x + x*y`   -- (¬¨x ‚à® y)

**ZK/R1CS.lean**

* `structure R1CS := (A B C : List (LinComb)) ...`
* `def satisfies (assign : VarId ‚Üí F) : Prop := ‚àÄ i, (A·µ¢¬∑a) * (B·µ¢¬∑a) = (C·µ¢¬∑a)`

**ZK/R1CSBool.lean**

* Compile the canonical `BoolLens` trace to R1CS: allocate wires, enforce booleanity, and emit equality constraints for `push`, `and`, `or`, `imp`.
* Invariants (`Matches`, `Bounded`, `Invariant`) established; `pushConst` case proved. Pending: extend invariant proofs to `applyAnd`/`applyOr`/`applyImp`, then lift to `compileSteps` for global soundness/completeness.

**ZK/R1CSSoundness.lean** *(planned)*

* **Soundness:** if `assign` comes from `compile`, then `system.satisfied assignment` and the decoded output equals `evalŒ© œÜ œÅ`.
* **Completeness:** given `œÅ`, the canonical witness satisfies the R1CS.

**ZK/Export.lean** *(planned)*

* Serialize the R1CS system/witness (`r1cs.json`, `witness.json`) for external SNARK tooling.

### E2 invariant ‚Üí compiled R1CS pipeline (ordered worklist)

1. **Finalize invariant primitives (in progress):**
   - Landed `Builder.system`, `SupportOK`, and the bundled `StrongInvariant` (with projector lemmas and `StrongInvariant.toInvariant`) in `R1CSBool.lean`.
   - Added the initial builder simp facts (`system_fresh`, `system_addConstraint`, `system_recordBoolean`) plus the fresh-variable helpers (`fresh_preserve_support`, `fresh_agreesOn_range`, `fresh_preserve_satisfied`).
   - ‚úÖ Next up: push the support/satisfaction plumbing through `addConstraint`/`recordBoolean`, extend the linear-combination support/satisfaction lemmas, and reprove `pushConst` under the strong invariant.
2. **Binary opcode preservation lemmas:**
   - Reprove `applyAnd`/`applyOr`/`applyImp` preservation with the strengthened primitive lemmas; keep the original invariant lemmas as corollaries until all call sites switch over.
3. **`compileStep` wrapper:**
   - Define `compileStep_preserves_strong` dispatching to the strong push/AND/OR/IMP lemmas; derive the existing lemma from it.
   - Provide a trivial ‚Äúinvalid trace‚Äù branch that returns the invariant unchanged.
4. **`compileSteps` induction:**
   - Prove `compileSteps_preserves_strong` by induction, threading `traceFrom` and the strong invariant.
   - Specialise to the lightweight invariant for backwards compatibility.
5. **Constraint satisfaction + witness extraction:**
   - Use the strong invariant to show `builder.constraints` are satisfied (`compiled_satisfies`) and that booleanity holds for every allocated wire.
   - Ensure the output alignment lemma (`compiled_output_matches`) continues to use `Matches.length_eq` and VM correctness.
6. **Soundness/completeness statements (`ZK/R1CSSoundness.lean`):**
   - Package the above into `compiled_sound` and `compiled_complete`, relating the builder witness to the canonical trace from `BoolLens`.
   - Bridge these results to the existing `Witness`/`PCT` layer so the CLI can reuse the Lean proofs.
7. **Refactor `compileStep` implementation if necessary:** ensure the Lean code matches the proof structure (e.g., reuse helper functions for readability once all lemmas exist).

### Soundness/completeness integration checklist

1. **Constraint satisfaction proof:** utilise `compiled_satisfies` to show `System.satisfied compiled.assignment compiled.system`.
2. **Output alignment:** combine `compiled_output_matches` with `BoolLens.exec_compile_aux` to rewrite the decoded result to `BoolLens.eval`.
3. **Theorems:** record the final `compiled_sound` / `compiled_complete` statements for re-use across the CLI and regression tests.
4. **Witness bridge:** map the compiled assignment into the existing PCT witness relation so verification can operate on a single canonical format.

### Phase‚ÄØE3 wiring notes

- **Executable plumbing:** after soundness/completeness, add `lake exe pct_r1cs` that runs `compile`, writes `r1cs.json`/`assignment.json`, and (optionally) hashes the trace metadata alongside `pct_prove`/`pct_verify`.
- **JSON schema:** reuse the existing codec helpers in `Contracts` for `Form`, `Env`, and extend them with simple encoders for `LinComb` (`const`, `terms`) and constraints (`A`, `B`, `C`) so downstream SNARK tooling can parse the artefacts.
- **Regression hooks:** add `Tests/CryptoSuite.lean` cases that call the new theorems on sample formulas; for CLI smoke tests, shell out to `lake exe pct_r1cs` with a two-variable example and check the emitted assignment matches `BoolLens.eval`.

---

## 5) Models & computations (finite demos)

**Models/Bool.lean**

* Instantiates `Lens` with `Carrier = Bool` ‚äÜ `{0,1}` and proves all lens laws.
* Exhaustive tables for 2‚Äì3 variables: check `compile_correct` by `#eval`.

**Models/FinGraph.lean**

* Finite preorder on `Fin n`; lens carrier = opens (down-sets); `Int = OpenHull`.
* Small enumerations to visualize `‚à®ÃÇ` as open-hull of unions.

---

## 6) Tests & executables

**Tests/ProofSuite.lean (MUST pass with `-Dno_sorry`)**

* Imports everything; checks:

  * Heyting on `Œ©_R`, residuation.
  * Transport soundness (generic).
  * `compile_correct` (generic).
  * R1CS soundness/completeness for Bool lens.

**Tests/FiniteCompute.lean**

* `#eval` tables for Bool and small graphs; print decoded equality checks.

**Exec/pct_prove.lean**

* Reads `env.json` + `œÜ.json`, runs `run L (compile œÜ) (enc ‚àò œÅ)`, emits `trace.json` + `out.json`.

**Exec/pct_verify.lean**

* Replays trace; checks that `dec out = evalŒ© œÜ œÅ`.
* Also option `--r1cs` to check `assignment.json` satisfies exported `r1cs.json`.

---

# üîê ‚ÄúReal-world crypto readiness‚Äù checklist

**Mathematical**

* [x] `compile_correct` proven (no `sorry`).
* [x] Witness soundness/completeness proven.
* [ ] Boolean lens R1CS soundness/completeness proven.

**Engineering (deterministic & safe)**

* [ ] Executables compiled from the same Lean sources (so the VM *is* the proved function).
* [ ] Inputs validated (booleans/ranges; no NaNs).
* [ ] Transcript format stable (hash over `(spec_commit, lens_id, prog, env, trace, out)`).

**Interoperability**

* [ ] `r1cs.json` schema compatible with standard provers (arkworks/bellman/circom-like field & wiring).
* [ ] `witness.json` uses the same wire order as `r1cs.json`.

**Security**

* [ ] For Bool lens: all wires constrained boolean.
* [ ] For other lenses: (deferred) introduce range proofs or discretizations before arithmetization.

---

## üß© Minimal agent TODOs (copy-paste tasks)

- [x] Create modules exactly as listed; wire `lake build -- -Dno_sorry -DwarningAsError=true`.
- [x] Implement Boolean VM specialisation (`Crypto/BoolLens`) and canonical traces.
- [x] Implement `compile`, `VM.run`, and prove `compile_correct`.
- [x] Prove transport soundness once; derive `compile_correct`.
- [ ] Extend the Boolean invariants:
    0. ‚úÖ Strengthen `Crypto/ZK/Support.lean` with the helper lemmas we actually need: `LinComb.support_single`, `LinComb.support_ofConst`, `LinComb.eval_single`, `LinComb.eval_ofConst`, and the constraint-specific support/satisfaction facts for `boolConstraint`/`eqConstConstraint`.
    1. ‚úÖ Use those helpers to extend `Crypto/ZK/R1CSBool.lean`: add the `SupportOK`/`satisfied` preservation lemmas for `fresh`, `addConstraint`, and `recordBoolean` (relying on `Builder.system_addConstraint`/`Builder.system_recordBoolean` rather than raw list manipulations) and package the subset facts (`range_subset_succ`, `singleton_subset_range`, `AgreesOn.mono`) so `StrongInvariant` proofs can `simp`.
    2. ‚úÖ Reprove `pushConst` against `StrongInvariant`, keeping the booleanity proof isolated in the head lemmas.
    3. ‚úÖ Show the existing invariant is a projection of `StrongInvariant` (`StrongInvariant.toInvariant` now lives in `R1CSBool.lean` alongside the field accessors).
    4. Build out the strong opcode proofs using the current `mulConstraint`/`eqConstraint` API and the helper wrappers we just added: `BuilderPreserve.fresh_preserve_satisfied`, `BuilderPreserve.addConstraint_preserve_satisfied`, and `BuilderPreserve.recordBoolean_preserve_satisfied`.
       - add the missing local lemmas that `applyAnd_strong` already relies on (`mulConstraint_support_subset`, boolean closure facts) so the proof compiles without placeholders;
       - refactor `applyAnd_strong` to reuse those helpers and finish by lifting the existing weak lemma;
       - replicate the pattern for `applyOr_strong` and `applyImp_strong`;
       - keep the helper lemmas adjacent to the opcode proofs so `compileStep_strong` can reuse them.
    5. Induct over `compileSteps` with the strong invariant to obtain full soundness/completeness for the generated R1CS, exposing witness/output to the CLI layer.
    ‚Üí Merge back into `main` once (4) and (5) are complete and `lake build -- -Dno-sorry -DwarningAsError=true` (CI) passes.
- [ ] Add executables (`pct_prove`, `pct_verify`, `pct_r1cs`) and regression demos.

When those 7 are green, you have **verified-by-construction Multi-Lens ZK + PCT** with a **cryptographically consumable** output format‚Äîand you can add more lenses or richer arithmetization with confidence later.


***NOTES***
Got it‚Äîhere‚Äôs a concrete, low-risk **staged retry plan** that keeps the build green at every step, fixes the pain points you hit (support unions, `System.satisfied` shape, missing invariants), and gets `applyAnd_strong` refactored before touching `Or/Imp`. I‚Äôve written this like an engineering playbook you can follow right now.

---

# Plan: Refactor in bite-size commits (each compiles)

## Stage 0 ‚Äî Freeze the shape of `System.satisfied` (no logic changes)

**Goal:** stop Lean from expanding back to the old function shape so your new prop-shaped lemmas apply uniformly.

1. Introduce a single congruence lemma and use it *only* where you want the structural view:

```lean
-- Crypto/ZK/Support.lean
namespace System

/-- Canonical structural view of `satisfied`. Keeps proofs uniform. -/
def satisfied_cons (S : System) (c : Constraint) : Prop := satisfied S c

@[simp] theorem satisfied_iff_cons :
  System.satisfied S c ‚Üî System.satisfied_cons S c := Iff.rfl

end System
```

**Usage pattern:** in proofs that must use the new helpers,
`simp [System.satisfied_iff_cons]` *at the top*, and don‚Äôt unfold `satisfied` anywhere else.
**Commit:** ‚ÄúStage0: add `satisfied_cons` shim + simp lemma (no behavior change).‚Äù

> Why this helps: you aren‚Äôt fighting definitional unfolding anymore‚Äîyou opt-in to a single stable surface (`satisfied_cons`), so your preservation wrappers always match.

---

## Stage 1 ‚Äî Support monotonicity lemmas (imported, no edits to R1CSBool yet)

**Goal:** fix the ‚Äúsupport subset union/ordering‚Äù issues once, then reuse everywhere.

Create **Crypto/ZK/Support.lean** (or extend it if it already exists) with *finset-level* facts only:

```lean
namespace Constraint

@[simp] lemma support_nil : support [] = (‚àÖ : Finset Var) := by
  -- your existing def ‚Üí finset ext

lemma support_append (cs‚ÇÅ cs‚ÇÇ : List Constraint) :
  support (cs‚ÇÅ ++ cs‚ÇÇ) = support cs‚ÇÅ ‚à™ support cs‚ÇÇ := by
  -- ext v; simp [support, List.mem_append, mem_union]

lemma support_perm {cs cs' : List Constraint} (h : cs ~ cs') :
  support cs = support cs' := by
  -- by perm induction; uses support_append + simp

end Constraint

namespace System

lemma support_addConstraint_union
  (S : System) (c : Constraint) :
  support S.constraints' = support S.constraints ‚à™ c.support := by
  -- whatever your field is called; adapt names

lemma support_recordBoolean_mono
  (S S' : System) (h : S' = S.recordBoolean x b) :
  support S'.constraints ‚äÜ support S.constraints := by
  -- recordBoolean only changes assignment, not constraints

end System
```

Also add two tiny ‚Äúfreshness‚Äù facts you‚Äôll need later:

```lean
def Fresh (S : System) (i : Var) : Prop := i ‚àâ S.assignment.dom ‚àß i ‚àâ support S.constraints

lemma fresh_not_in_support {S i} (h : Fresh S i) :
  i ‚àâ support S.constraints := h.right
```

**Commit:** ‚ÄúStage1: support union/perm + recordBoolean monotonicity + Fresh.‚Äù

---

## Stage 2 ‚Äî ‚ÄúPreserve satisfied‚Äù wrappers (the Prop-shaped helpers)

**Goal:** re-introduce your three wrappers, but *only* relying on Stage 1 lemmas.

```lean
namespace BuilderPreserve

open System

/-- Adding a fresh boolean variable does not break satisfaction of existing constraints. -/
lemma recordBoolean_preserve_satisfied
  {S S' : System} {cs : List Constraint} {i : Var} {b : Bool}
  (hFresh : Fresh S i)
  (hStep  : S' = S.recordBoolean i b)
  (hSat   : satisfied_cons S cs) :
  satisfied_cons S' cs := by
  -- proof idea: agree on all indices in support cs; hFresh ensures disjointness.
  -- use Stage1 `support_recordBoolean_mono` + ‚Äúagree on support‚Äù helper.

lemma addConstraint_preserve_satisfied
  {S S' : System} {cs : List Constraint} {c : Constraint}
  (hStep : S' = S.addConstraint c)
  (hSat  : satisfied_cons S cs) :
  satisfied_cons S' cs := by
  -- constraints for `cs` unchanged; use Stage1 union lemma to localize.

lemma fresh_preserve_satisfied
  {S S' : System} {cs : List Constraint} {i : Var}
  (hFresh : Fresh S i)
  (hExtend : S' = S.extendFresh i) -- or your actual name
  (hSat : satisfied_cons S cs) :
  satisfied_cons S' cs := by
  -- same shape as recordBoolean, but for a generic ‚Äúextend‚Äù
end BuilderPreserve
```

**Compile after each lemma** with the tree untouched.
**Commit:** ‚ÄúStage2: Prop-shaped preservation lemmas, no R1CSBool edits.‚Äù

---

## Stage 3 ‚Äî Local invariant shims (avoid the ‚Äúunknown identifier‚Äù errors)

**Goal:** decouple `R1CSBool` from a moving invariant API.

Add a tiny *adapter* module that only depends on fields you actually use:

```lean
-- Crypto/ZK/InvariantShim.lean
structure WeakInvariant (S : System) : Prop :=
  (agree_on_support :
     ‚àÄ {S' cs}, support S'.constraints ‚äÜ support S.constraints ‚Üí
       System.agreeOn (support cs) S.assignment S'.assignment)

namespace StrongInvariant
/-- Backfill for older files: provide `.toWeak` so code compiles. -/
def toWeak {S} (h : StrongInvariant S) : WeakInvariant S := {
  agree_on_support := by
    -- implement from StrongInvariant‚Äôs fields if available,
    -- or provide the minimal lemma you need.
}
end StrongInvariant
```

Then, in places that referenced `StrongInvariant.toInvariant`, replace with `.toWeak`.
**Commit:** ‚ÄúStage3: invariant shim (`WeakInvariant`) with `StrongInvariant.toWeak`.‚Äù

---

## Stage 4 ‚Äî Refactor `applyAnd_strong` only

**Goal:** touch a single opcode, using the new wrappers + stable `satisfied_cons`.

Refactor outline:

```lean
-- Crypto/ZK/R1CSBool.lean
theorem applyAnd_strong
  (Hinv : StrongInvariant S)
  (hSat : System.satisfied_cons S cs)
  -- ‚Ä¶ your other preconditions ‚Ä¶
  : System.satisfied_cons S' cs := by
  -- 0) normalize shape
  simp [System.satisfied_iff_cons] at hSat ‚ä¢

  -- 1) decompose the builder step into the small steps you actually perform
  --    (recordBoolean, addConstraint, fresh, etc.), each closed by Stage2 lemmas.
  have h1 : satisfied_cons S‚ÇÅ cs := BuilderPreserve.recordBoolean_preserve_satisfied ?fresh rfl hSat
  have h2 : satisfied_cons S‚ÇÇ cs := BuilderPreserve.addConstraint_preserve_satisfied rfl h1
  -- ‚Ä¶

  -- 2) where you need ‚Äúagreement on old support,‚Äù call the shim:
  have W := (Hinv.toWeak).agree_on_support (by
    -- reuse Stage1 support lemmas to show subset)

  -- 3) finish with simp/finset ext; avoid expanding `satisfied`.
  simpa using hFinal
```

> **Don‚Äôt** start `applyOr_strong` yet. Keep `Imp` untouched.

**Commit:** ‚ÄúStage4: refactor `applyAnd_strong` via preservation wrappers.‚Äù

---

## Stage 5 ‚Äî Add a scratch target & micro-tests

**Goal:** prevent another ‚Äúballoon then sorry‚Äù scenario.

Create **Crypto/ZK/Dev/Scratch.lean** with tiny unit tests:

```lean
example : System.satisfied_cons S cs ‚Üî System.satisfied_cons S cs := by
  -- sanity via the shim
  simp [System.satisfied_iff_cons]

example (h : Fresh S i) :
  System.satisfied_cons (S.recordBoolean i true) cs
    := BuilderPreserve.recordBoolean_preserve_satisfied h rfl ?hSat
```

Wire a `lake exe zk-mini` (or a `#[test]` if you use a test harness) that only builds `Support`, `InvariantShim`, and `Scratch`.
**Commit:** ‚ÄúStage5: scratch target & micro tests (keeps compile times tiny).‚Äù

---

## Stage 6 ‚Äî Only then: `applyOr_strong`, then `applyImp_strong`

Repeat Stage 4 for `Or`, then for `Imp`.
If `Or` explodes in proof size, isolate the boolean closure lemma first (e.g., `bool_or_closure`), prove it in `Support.lean`, and use it as a single step inside the opcode proof.

**Commit(s):** ‚ÄúStage6A: refactor `applyOr_strong`,‚Äù then ‚ÄúStage6B: refactor `applyImp_strong`.‚Äù

---

# Tactics & simp sets that will save you hours

* Put this at the top of the affected sections:

```lean
open Finset
attribute [simp] System.satisfied_iff_cons
```

* When you need set/finset equalities:

```lean
  ext v <;> by_cases hv : v ‚àà support _ <;> simp [hv]
```

* For subset chains:

```lean
  refine subset_trans ?_ (by simp [Constraint.support_append])
```

* To stop unwanted unfolding:

```lean
  set_option tactic.hygienic true
  -- and prefer `simp [System.satisfied_iff_cons]` over `unfold`
```

* Use `simp_all` *late*, not early‚Äîafter you‚Äôve established the right shape via your Stage 0 lemma.

---

# How the lenses can help during each stage (optional but useful)

* **Graph lens**: query OpenHull of your goal to surface the *minimal* lemmas you need; keeps `applyAnd_strong` localized.
* **Tensor lens**: re-rank candidate helper lemmas by semantic proximity when the search space is noisy; the `Int` closure keeps the logic valid.
* **Topology lens**: if you‚Äôre lost, raise the dial to zoom out and find a coarser explanation set, then refine back down.
* **Operator lens**: check for ‚Äúnon-commuting tension‚Äù when two proof subpieces feel incompatible‚Äîif projection error is high, you‚Äôre mixing incompatible invariants; split the step.

(If you‚Äôve wired the MCP tools from earlier, script your agent to call `lens.query{mode:"abduce", lens:"graph"}` before editing a proof, and `lens.verify` after each patch.)

---

# What to do right now (TL;DR checklist)

1. **Add Stage 0 shim** (`satisfied_cons` + `satisfied_iff_cons`). Build.
2. **Add Stage 1 support lemmas** (append/perm/union/mono + `Fresh`). Build.
3. **Add Stage 2 preservation wrappers** (`recordBoolean/addConstraint/fresh`). Build.
4. **Drop in Stage 3 invariant shim** (`WeakInvariant`, `.toWeak`). Build.
5. **Refactor only `applyAnd_strong`** using Stage 2 + shim. Build.
6. **Add Stage 5 scratch tests**. Build fast path.
7. **Proceed to `Or`, then `Imp`** if #5 is stable.
