Multi-lens proof-carrying transactions (ML-PCT) will sit on top of the nucleus-driven Heyting core and the transport infrastructure we already maintain under `lean/HeytingLean`. This document replaces the earlier adâ€‘hoc sketch with a Lean-first plan that matches the codebase, keeps proofs inside the existing build (`lake build -- -Dno_sorry -DwarningAsError=true`), and produces cryptographically consumable outputs (canonical traces and R1CS exports).

---

# 1â€¯â€¯Current Baseline

* **Core logic.** `HeytingLean/LoF` models the nucleus `R`, the fixed-point core `Î©_R`, and the stage semantics we already use for the bridge suite.
* **Lenses & transport.** `HeytingLean/Bridges` and `HeytingLean/Contracts` implement tensor, graph (Alexandroff), and Clifford lenses together with verified RT/TRI contracts. `HeytingLean/Runtime/BridgeSuite` exposes the multi-lens runtime entry point.
* **Proof widgets.** `HeytingLean/ProofWidgets` and the Law-of-Form blueprint give us graph visualisation, certified transports, and finite-model sanity checks.
* **Tooling.** `Docs/LoFBlueprint` (regenerated with `./tools/package_blueprint.sh`) tracks every Lean declaration; `lake build -- -Dno_sorry -DwarningAsError=true` is our CI target.

This plan assumes nothing beyond the current repo and keeps all new code under `lean/HeytingLean/Crypto` unless otherwise stated.

---

# 2â€¯â€¯Target Outcome

Verified-by-construction Multi-Lens ZK + Proof-Carrying Transactions with:

1. A shared **logical IR** interpreted in `Î©_R` and transported to every lens.
2. A **certified VM** + compiler per lens that preserve core semantics (RT/TRI aware).
3. A **witness relation** and proof objects whose soundness/completeness are proved in Lean.
4. A Boolean-lens lowering to **R1CS** plus JSON exporters so third-party provers can consume the circuit.
5. Executable entry points (`pct_prove`, `pct_verify`, `pct_r1cs`) generated by `lake exe` that inherit the theorems.

---

# Progress Snapshot

- âœ… Phaseâ€¯A â€“ Logical IR (`Crypto/Form`, `Crypto/CoreSemantics`).
- âœ… Phaseâ€¯B â€“ Lens abstraction & transport (`Crypto/Lens/*`).
- âœ… Phaseâ€¯C â€“ Postfix VM, compiler, and correctness (`Crypto/Prog`, `Crypto/VM`, `Crypto/Compile`, `Crypto/Correctness`).
- âœ… Phaseâ€¯D â€“ Witness relation & PCT payload (`Crypto/Witness`, `Crypto/PCT`).
- âœ… Phaseâ€¯E1 â€“ Boolean VM specialisation with canonical traces (`Crypto/BoolLens`).
- ğŸŸ¡ Phaseâ€¯E2 â€“ Boolean arithmetisation & R1CS scaffolding (`Crypto/ZK/BoolArith`, `Crypto/ZK/R1CS`, `Crypto/ZK/R1CSBool`).  
  _Current status:_  
  â€¢ Canonical BoolLens trace/value available (`Crypto/BoolLens`).  
  â€¢ Support-oriented utilities factored out (`Crypto/ZK/Support`) giving `AgreesOn`, `support`, and `System.satisfied_ext` lemmas (ready for use).  
  â€¢ R1CS compiler emits witness/constraints for all opcodes (no global proof yet).  
  â€¢ `linhead_imp` helpers now mirror the OR-head path so the backend treats implication uniformly (`Crypto/ZK/R1CSBool.lean`:291).  
  â€¢ `applyImp_strong` threads the strengthened invariant through the implication opcode (`Crypto/ZK/R1CSBool.lean`:1653).  
  â€¢ `compileStep_strong` and `compileSteps_strong` propagate the strong invariant across the builder pipeline using the canonical `traceFrom`/`exec` pair (`Crypto/ZK/R1CSBool.lean`:2145, 2442).  
  â€¢ `lake build -- -Dno_sorry -DwarningAsError=true` passes (warning set unchanged).  
  _Next steps (active work queue):_  
  1. Refactor the `applyAnd_strong` and `applyOr_strong` proofs to eliminate the remaining `simp`/`simpa` calls (replace them with explicit `rw`/`simp â€¦ at` steps while reusing the cached equalities).  
  2. Update `compileStep_strong`â€™s base cases (`pushTop`, `pushBot`, `pushVar`) to follow the `simp at â€¦; subst` pattern recommended by the linter, then re-run the build to confirm the warning set shrinks.  
  3. Once the linter is clean, leverage the strengthened invariant to finish the Boolean R1CS soundness/completeness proofs.  
  4. Expose the completed proofs through the CLI and R1CS exporters.
- â³ Phaseâ€¯E3 â€“ CLI executables and regression tests (not started).

**Next Session Jumpstart**

1. `lean/HeytingLean/Crypto/ZK/R1CSBool.lean`: rewrite `applyAnd_strong` and `applyOr_strong` so the cached fresh/addConstraint equalities are used via `rw`/`simp at`, not `simpa`.  
2. In the same file, adjust the `pushTop`/`pushBot`/`pushVar` branches of `compileStep_strong` to use the `simp â€¦ at hStep; subst hStep` style and address the zero-length contradictions with `simp` on the length hypotheses.  
3. Re-run `lake build -- -Dno_sorry -DwarningAsError=true`; note any remaining linter warnings and continue iterating until the build is clean.

Current focus: finish the warning clean-up, then push through the Boolean R1CS soundness/completeness proofs before wiring the CLI exporters.

---

# 3â€¯â€¯Delivery Plan

## Phase A â€“ Logical IR and Core Semantics âœ…

- [x] `HeytingLean/Crypto/Form.lean` â€“ inductive IR over `Fin n` variables with Heyting connectives.
- [x] `HeytingLean/Crypto/CoreSemantics.lean` â€“ environment alias and `Form.evalÎ©` lemmas (`evalÎ©_and`, `evalÎ©_imp`, â€¦).

Deliverable status: âœ… `Form.evalÎ©` proved and in CI.

## Phase B â€“ Lens Semantics & Transport âœ…

- [x] `HeytingLean/Crypto/Lens/Class.lean` â€“ reusable `Lens` structure with lift helpers (`enc`, `dec`, `logicalShadow`, stack-friendly ops).
- [x] `HeytingLean/Crypto/Lens/Semantics.lean` â€“ lens-side environments and `Form.evalL`.
- [x] `HeytingLean/Crypto/Lens/Transport.lean` â€“ transport lemma `dec (evalL _ (enc âˆ˜ Ï)) = evalÎ© _ Ï`.

Deliverable status: âœ… transport soundness available for any `Lens`.

## Phase C â€“ Certified Program Representation âœ…

- [x] `HeytingLean/Crypto/Prog.lean` â€“ postfix instruction set (`Instr`, `Program`).
- [x] `HeytingLean/Crypto/VM.lean` â€“ stack machine with traces (`run`, `traceFrom`, lemmas like `exec_append`).
- [x] `HeytingLean/Crypto/Compile.lean` â€“ structural compiler and lemmas (`exec_compile_aux`, `run_compile_value`).
- [x] `HeytingLean/Crypto/Correctness.lean` â€“ canonical run/value helpers and theorem `compile_correct`.

Deliverable status: âœ… `compile_correct` ready for downstream lenses.

## Phase D â€“ Witness Relation & Proof-Carrying Transactions âœ…

- [x] `HeytingLean/Crypto/Witness.lean` â€“ canonical witness trace & relation, soundness/completeness lemmas.
- [x] `HeytingLean/Crypto/PCT.lean` â€“ payload structure, verification predicate, completeness witness.
- [ ] Executables (`Exec/pct_prove`, `Exec/pct_verify`) â€“ pending (see Phaseâ€¯E3).

Deliverable status: âœ… proof-carrying payload in Lean; CLI generation outstanding.

## Phase E â€“ Zero-Knowledge Lowering (Boolean Lens) â€“ In Progress

- âœ… **E1 â€“ Boolean VM specialisation (`HeytingLean/Crypto/BoolLens.lean`).**
  - Standalone Boolean evaluator (`eval`) and stack VM mirroring the generic pipeline.
  - Canonical `Trace`/`Value` helpers with lemma `canonicalValue_eq_eval`.
- ğŸŸ¡ **E2 â€“ R1CS backend.**
- âœ… Boolean-to-field lemmas (`HeytingLean/Crypto/ZK/BoolArith`), minimal R1CS primitives (`HeytingLean/Crypto/ZK/R1CS`), and an initial compiler plus stack invariants (`HeytingLean/Crypto/ZK/R1CSBool` â€“ `pushConst` case proven).
- â³ Extend invariants to `applyAnd`/`applyOr`/`applyImp`, then prove the generated R1CS instance is sound/complete w.r.t. `BoolLens`, surfacing the witness/output to the CLI layer.
- â³ **E3 â€“ Exporters.**
  - TODO: `Exec/pct_r1cs.lean`, JSON wiring, optional SNARK hand-off.

Deliverable: SNARK-friendly artefacts (pending).

## Phase F â€“ Testing & Tooling

1. **Deterministic finite models (`HeytingLean/Crypto/Models.lean`).**
   * Use the existing Alexandroff and tensor sample models for #eval regression tests.
2. **Test harness (`lean/Tests/CryptoSuite.lean`).**
   * Import all theorems, run sample forms through every lens.
3. **Blueprint updates.**
   * Document the new declarations in `Docs/LoFBlueprint` (the packaging script does the heavy lifting).
   * Add a short operatorâ€™s guide in `Docs/CryptoStack.md`.

Deliverable: a repeatable test suite invoked by `lake build` and CI.

---

# 4â€¯â€¯Build & Integration Checklist

1. **Lean build:** `cd lean && lake build -- -Dno_sorry -DwarningAsError=true`. âœ…
2. **Blueprint regeneration:** `cd blueprint && ./tools/package_blueprint.sh`.
3. **Executables:**
   * `lake exe pct_prove form.json env.json`. â³
   * `lake exe pct_verify form.json env.json trace.json`. â³
   * `lake exe pct_r1cs form.json env.json`. â³
4. **Optional SNARK test:** feed the generated `r1cs.json` + `assignment.json` into an external prover (outside the Lean repo).

---

# 5â€¯â€¯Success Criteria

- âœ… All new Lean files compile with zero `sorry` under the existing CI settings.
- âœ… `transport_sound` holds for every registered lens (tensor, graph, Clifford, Boolean via `BoolLens` semantics).
- âœ… VM correctness theorem (`compile_correct`) is in `HeytingLean.Crypto`.
- â³ PCT executables round-trip deterministic traces and align with the Lean proof.
- â³ Boolean lowering produces R1CS artefacts whose satisfaction proof is checked in Lean.

This plan keeps us aligned with the current codebase, leverages the bridge suite that already runs inside `lake env`, and yields cryptographically consumable artefacts backed by machine-checked proofs.

* `def compile : Form â†’ Prog` (postfix codegen).
* Lemma `compile_evalL`: `evalL L Ï† Ï = (run L (compile Ï†) Ï).snd`
  (induction on `Ï†`; VM aligns with evalL by construction).

**Cert/Correctness.lean**

* Combine `compile_evalL` with `transport_sound`:

```lean
theorem compile_correct (L) :
  âˆ€ Ï† Ï, L.dec (Prod.snd (run L (compile Ï†) (L.enc âˆ˜ Ï)))
      = evalÎ© Ï† Ï
```

This is the **central theorem** that makes the binaries proof-carrying by construction.

**Cert/Witness.lean**

* `def W_L (L) (Ï† Ï t) : Prop := t = (run L (compile Ï†) (L.enc âˆ˜ Ï)).fst`
* **Soundness:** `W_L L Ï† Ï t â†’ L.dec (out t) = evalÎ© Ï† Ï`
* **Completeness:** `âˆƒ t, W_L L Ï† Ï t`

---

## 4) Boolean-lens R1CS (ZK-ready)

Start with the **Bool lens** (`Int = id`, values in {0,1}), which arithmetizes cleanly.

**ZK/BoolArith.lean**

* Boolean constraints: `b*(b-1)=0`
* Gates:

  * `z_and = x*y`
  * `z_or  = x + y - x*y`
  * `z_not = 1 - x`
  * `z_impl = 1 - x + x*y`   -- (Â¬x âˆ¨ y)

**ZK/R1CS.lean**

* `structure R1CS := (A B C : List (LinComb)) ...`
* `def satisfies (assign : VarId â†’ F) : Prop := âˆ€ i, (Aáµ¢Â·a) * (Báµ¢Â·a) = (Cáµ¢Â·a)`

**ZK/R1CSBool.lean**

* Compile the canonical `BoolLens` trace to R1CS: allocate wires, enforce booleanity, and emit equality constraints for `push`, `and`, `or`, `imp`.
* Invariants (`Matches`, `Bounded`, `Invariant`) established; `pushConst` case proved. Pending: extend invariant proofs to `applyAnd`/`applyOr`/`applyImp`, then lift to `compileSteps` for global soundness/completeness.

**ZK/R1CSSoundness.lean** *(planned)*

* **Soundness:** if `assign` comes from `compile`, then `system.satisfied assignment` and the decoded output equals `evalÎ© Ï† Ï`.
* **Completeness:** given `Ï`, the canonical witness satisfies the R1CS.

**ZK/Export.lean** *(planned)*

* Serialize the R1CS system/witness (`r1cs.json`, `witness.json`) for external SNARK tooling.

### E2 invariant â†’ compiled R1CS pipeline (ordered worklist)

1. **Finalize invariant primitives (in progress):**
   - Landed `Builder.system`, `SupportOK`, and the bundled `StrongInvariant` (with projector lemmas and `StrongInvariant.toInvariant`) in `R1CSBool.lean`.
   - Added the initial builder simp facts (`system_fresh`, `system_addConstraint`, `system_recordBoolean`) plus the fresh-variable helpers (`fresh_preserve_support`, `fresh_agreesOn_range`, `fresh_preserve_satisfied`).
   - âœ… Next up: push the support/satisfaction plumbing through `addConstraint`/`recordBoolean`, extend the linear-combination support/satisfaction lemmas, and reprove `pushConst` under the strong invariant.
2. **Binary opcode preservation lemmas:**
   - Reprove `applyAnd`/`applyOr`/`applyImp` preservation with the strengthened primitive lemmas; keep the original invariant lemmas as corollaries until all call sites switch over.
3. **`compileStep` wrapper:**
   - Define `compileStep_preserves_strong` dispatching to the strong push/AND/OR/IMP lemmas; derive the existing lemma from it.
   - Provide a trivial â€œinvalid traceâ€ branch that returns the invariant unchanged.
4. **`compileSteps` induction:**
   - Prove `compileSteps_preserves_strong` by induction, threading `traceFrom` and the strong invariant.
   - Specialise to the lightweight invariant for backwards compatibility.
5. **Constraint satisfaction + witness extraction:**
   - Use the strong invariant to show `builder.constraints` are satisfied (`compiled_satisfies`) and that booleanity holds for every allocated wire.
   - Ensure the output alignment lemma (`compiled_output_matches`) continues to use `Matches.length_eq` and VM correctness.
6. **Soundness/completeness statements (`ZK/R1CSSoundness.lean`):**
   - Package the above into `compiled_sound` and `compiled_complete`, relating the builder witness to the canonical trace from `BoolLens`.
   - Bridge these results to the existing `Witness`/`PCT` layer so the CLI can reuse the Lean proofs.
7. **Refactor `compileStep` implementation if necessary:** ensure the Lean code matches the proof structure (e.g., reuse helper functions for readability once all lemmas exist).

### Soundness/completeness integration checklist

1. **Constraint satisfaction proof:** utilise `compiled_satisfies` to show `System.satisfied compiled.assignment compiled.system`.
2. **Output alignment:** combine `compiled_output_matches` with `BoolLens.exec_compile_aux` to rewrite the decoded result to `BoolLens.eval`.
3. **Theorems:** record the final `compiled_sound` / `compiled_complete` statements for re-use across the CLI and regression tests.
4. **Witness bridge:** map the compiled assignment into the existing PCT witness relation so verification can operate on a single canonical format.

### Phaseâ€¯E3 wiring notes

- **Executable plumbing:** after soundness/completeness, add `lake exe pct_r1cs` that runs `compile`, writes `r1cs.json`/`assignment.json`, and (optionally) hashes the trace metadata alongside `pct_prove`/`pct_verify`.
- **JSON schema:** reuse the existing codec helpers in `Contracts` for `Form`, `Env`, and extend them with simple encoders for `LinComb` (`const`, `terms`) and constraints (`A`, `B`, `C`) so downstream SNARK tooling can parse the artefacts.
- **Regression hooks:** add `Tests/CryptoSuite.lean` cases that call the new theorems on sample formulas; for CLI smoke tests, shell out to `lake exe pct_r1cs` with a two-variable example and check the emitted assignment matches `BoolLens.eval`.

---

## 5) Models & computations (finite demos)

**Models/Bool.lean**

* Instantiates `Lens` with `Carrier = Bool` âŠ† `{0,1}` and proves all lens laws.
* Exhaustive tables for 2â€“3 variables: check `compile_correct` by `#eval`.

**Models/FinGraph.lean**

* Finite preorder on `Fin n`; lens carrier = opens (down-sets); `Int = OpenHull`.
* Small enumerations to visualize `âˆ¨Ì‚` as open-hull of unions.

---

## 6) Tests & executables

**Tests/ProofSuite.lean (MUST pass with `-Dno_sorry`)**

* Imports everything; checks:

  * Heyting on `Î©_R`, residuation.
  * Transport soundness (generic).
  * `compile_correct` (generic).
  * R1CS soundness/completeness for Bool lens.

**Tests/FiniteCompute.lean**

* `#eval` tables for Bool and small graphs; print decoded equality checks.

**Exec/pct_prove.lean**

* Reads `env.json` + `Ï†.json`, runs `run L (compile Ï†) (enc âˆ˜ Ï)`, emits `trace.json` + `out.json`.

**Exec/pct_verify.lean**

* Replays trace; checks that `dec out = evalÎ© Ï† Ï`.
* Also option `--r1cs` to check `assignment.json` satisfies exported `r1cs.json`.

---

# ğŸ” â€œReal-world crypto readinessâ€ checklist

**Mathematical**

* [x] `compile_correct` proven (no `sorry`).
* [x] Witness soundness/completeness proven.
* [ ] Boolean lens R1CS soundness/completeness proven.

**Engineering (deterministic & safe)**

* [ ] Executables compiled from the same Lean sources (so the VM *is* the proved function).
* [ ] Inputs validated (booleans/ranges; no NaNs).
* [ ] Transcript format stable (hash over `(spec_commit, lens_id, prog, env, trace, out)`).

**Interoperability**

* [ ] `r1cs.json` schema compatible with standard provers (arkworks/bellman/circom-like field & wiring).
* [ ] `witness.json` uses the same wire order as `r1cs.json`.

**Security**

* [ ] For Bool lens: all wires constrained boolean.
* [ ] For other lenses: (deferred) introduce range proofs or discretizations before arithmetization.

---

## ğŸ§© Minimal agent TODOs (copy-paste tasks)

- [x] Create modules exactly as listed; wire `lake build -- -Dno_sorry -DwarningAsError=true`.
- [x] Implement Boolean VM specialisation (`Crypto/BoolLens`) and canonical traces.
- [x] Implement `compile`, `VM.run`, and prove `compile_correct`.
- [x] Prove transport soundness once; derive `compile_correct`.
- [ ] Extend the Boolean invariants:
    0. âœ… Strengthen `Crypto/ZK/Support.lean` with the helper lemmas we actually need: `LinComb.support_single`, `LinComb.support_ofConst`, `LinComb.eval_single`, `LinComb.eval_ofConst`, and the constraint-specific support/satisfaction facts for `boolConstraint`/`eqConstConstraint`.
    1. âœ… Use those helpers to extend `Crypto/ZK/R1CSBool.lean`: add the `SupportOK`/`satisfied` preservation lemmas for `fresh`, `addConstraint`, and `recordBoolean` (relying on `Builder.system_addConstraint`/`Builder.system_recordBoolean` rather than raw list manipulations) and package the subset facts (`range_subset_succ`, `singleton_subset_range`, `AgreesOn.mono`) so `StrongInvariant` proofs can `simp`.
    2. âœ… Reprove `pushConst` against `StrongInvariant`, keeping the booleanity proof isolated in the head lemmas.
    3. âœ… Show the existing invariant is a projection of `StrongInvariant` (`StrongInvariant.toInvariant` now lives in `R1CSBool.lean` alongside the field accessors).
    4. âœ… Build out the strong opcode proofs using the current `mulConstraint`/`eqConstraint` API and the helper wrappers we just added (`BuilderPreserve.fresh_preserve_satisfied`, `BuilderPreserve.addConstraint_preserve_satisfied`, `BuilderPreserve.recordBoolean_preserve_satisfied`).
       - âœ… add the missing local lemmas that `applyAnd_strong` relies on (`mulConstraint_support_subset`, boolean closure facts) so the proof compiles without placeholders;
       - âœ… refactor `applyAnd_strong` to reuse those helpers and finish by lifting the existing weak lemma;
       - âœ… replicate the pattern for `applyOr_strong` and `applyImp_strong`;
       - âœ… keep the helper lemmas adjacent to the opcode proofs so `compileStep_strong` can reuse them.
    5. âœ… Prove the stepwise and inductive preservation lemmas (`compileStep_strong`, `compileSteps_strong`) so every `compileSteps` call carries the strong invariant along the Boolean program.
    6. â³ Thread the strengthened invariant into the top-level `compile` correctness proof so the canonical builder run produces a `StrongInvariant` (first pass landed `compile_support_subset`; satisfaction lemmas still pending).
    7. ğŸ”„ Clear the warning backlog (`linhead_imp_support` + lingering `simp`/`simpa`) to keep `-DwarningAsError` future-proof.
    8. â³ Finish the Boolean R1CS soundness/completeness proofs and surface the results to the CLI and exporters.
    â†’ Merge back into `main` once step 8 is complete, the global theorems surface the witness assignment, and `lake build -- -Dno-sorry -DwarningAsError=true` (CI) stays green.
- [ ] Add executables (`pct_prove`, `pct_verify`, `pct_r1cs`) and regression demos.

When those 7 are green, you have **verified-by-construction Multi-Lens ZK + PCT** with a **cryptographically consumable** output formatâ€”and you can add more lenses or richer arithmetization with confidence later.


***NOTES***
Got itâ€”hereâ€™s a concrete, low-risk **staged retry plan** that keeps the build green at every step, fixes the pain points you hit (support unions, `System.satisfied` shape, missing invariants), and gets `applyAnd_strong` refactored before touching `Or/Imp`. Iâ€™ve written this like an engineering playbook you can follow right now.

---

# Plan: Refactor in bite-size commits (each compiles)

## Stage 7 â€” Thread `compileSteps_strong` into the top-level compile proof

**Goal:** derive a `StrongInvariant` guarantee for the canonical builder run so the global Boolean proofs can consume it.

**Status:** ğŸ”„ `compile_strong` now feeds `compile_support_subset` and a direct `compile_system_satisfied`; the `System.satisfied_cons` corollary and merge criteria remain queued behind the lint cleanup.

1. Bridge the existing `compile` correctness proof to `compileSteps_strong`, reusing the canonical `traceFrom`/`exec` pair.
2. Extend the main theorem to expose both the legacy invariant and the new strong invariant (use `StrongInvariant.toWeak` for back-compat).
3. Keep the upgrade localized to `Crypto/ZK/R1CSBool.lean`, then restate the downstream lemmas (`compile_strong`, `compile_agrees`, â€¦) in terms of the strong result.
4. Leave TODO markers where soundness/completeness will plug in so the next stage has clear insertion points.

## Stage 8 â€” Clear the warning backlog

**Goal:** make `-DwarningAsError=true` green by fixing the lingering `simp`/`simpa` issues and the unused helper parameter.

- Drop the unused variable in `linhead_imp_support` (or replace it with `_`) and ensure `simp` reduces cleanly.
- Rephrase the remaining `simp`/`simpa` calls flagged by the linter so they no longer require manual rewrites.
- Re-run `lake build -- -Dno_sorry -DwarningAsError=true`; the compile should be clean with zero warnings.

## Stage 9 â€” Finish Boolean R1CS soundness/completeness under the strong invariant

**Goal:** use the new compile theorem to close the Boolean R1CS soundness/completeness statements.

1. Strengthen the soundness lemma so the compiled `(system, assignment)` inherits the `StrongInvariant` facts (support + satisfaction).
2. Instantiate the canonical trace/assignment to prove completeness, relying on `compileSteps_strong` instead of ad-hoc stack arguments.
3. Package the results so downstream consumers get both the Boolean evaluation equality and the corresponding satisfying assignment.

## Stage 10 â€” Surface CLI + exporters with the new proofs

**Goal:** expose the verified pipeline to users and automate artifact generation.

- Wire `lake exe pct_prove`, `pct_verify`, and `pct_r1cs` to the strengthened theorems.
- Ensure the R1CS exporter uses the final witness assignment and emits JSON consumable by external provers.
- Add regression tests or demos that call the executables and assert the strong results.

---

### Archive â€” Stageâ€¯0â€¯â€“â€¯6 (completed; kept for reference)

## Stage 0 â€” Freeze the shape of `System.satisfied` (no logic changes)

**Goal:** stop Lean from expanding back to the old function shape so your new prop-shaped lemmas apply uniformly.

1. Introduce a single congruence lemma and use it *only* where you want the structural view:

```lean
-- Crypto/ZK/Support.lean
namespace System

/-- Canonical structural view of `satisfied`. Keeps proofs uniform. -/
def satisfied_cons (S : System) (c : Constraint) : Prop := satisfied S c

@[simp] theorem satisfied_iff_cons :
  System.satisfied S c â†” System.satisfied_cons S c := Iff.rfl

end System
```

**Usage pattern:** in proofs that must use the new helpers,
`simp [System.satisfied_iff_cons]` *at the top*, and donâ€™t unfold `satisfied` anywhere else.
**Commit:** â€œStage0: add `satisfied_cons` shim + simp lemma (no behavior change).â€

> Why this helps: you arenâ€™t fighting definitional unfolding anymoreâ€”you opt-in to a single stable surface (`satisfied_cons`), so your preservation wrappers always match.

---

## Stage 1 â€” Support monotonicity lemmas (imported, no edits to R1CSBool yet)

**Goal:** fix the â€œsupport subset union/orderingâ€ issues once, then reuse everywhere.

Create **Crypto/ZK/Support.lean** (or extend it if it already exists) with *finset-level* facts only:

```lean
namespace Constraint

@[simp] lemma support_nil : support [] = (âˆ… : Finset Var) := by
  -- your existing def â†’ finset ext

lemma support_append (csâ‚ csâ‚‚ : List Constraint) :
  support (csâ‚ ++ csâ‚‚) = support csâ‚ âˆª support csâ‚‚ := by
  -- ext v; simp [support, List.mem_append, mem_union]

lemma support_perm {cs cs' : List Constraint} (h : cs ~ cs') :
  support cs = support cs' := by
  -- by perm induction; uses support_append + simp

end Constraint

namespace System

lemma support_addConstraint_union
  (S : System) (c : Constraint) :
  support S.constraints' = support S.constraints âˆª c.support := by
  -- whatever your field is called; adapt names

lemma support_recordBoolean_mono
  (S S' : System) (h : S' = S.recordBoolean x b) :
  support S'.constraints âŠ† support S.constraints := by
  -- recordBoolean only changes assignment, not constraints

end System
```

Also add two tiny â€œfreshnessâ€ facts youâ€™ll need later:

```lean
def Fresh (S : System) (i : Var) : Prop := i âˆ‰ S.assignment.dom âˆ§ i âˆ‰ support S.constraints

lemma fresh_not_in_support {S i} (h : Fresh S i) :
  i âˆ‰ support S.constraints := h.right
```

**Commit:** â€œStage1: support union/perm + recordBoolean monotonicity + Fresh.â€

---

## Stage 2 â€” â€œPreserve satisfiedâ€ wrappers (the Prop-shaped helpers)

**Goal:** re-introduce your three wrappers, but *only* relying on Stage 1 lemmas.

```lean
namespace BuilderPreserve

open System

/-- Adding a fresh boolean variable does not break satisfaction of existing constraints. -/
lemma recordBoolean_preserve_satisfied
  {S S' : System} {cs : List Constraint} {i : Var} {b : Bool}
  (hFresh : Fresh S i)
  (hStep  : S' = S.recordBoolean i b)
  (hSat   : satisfied_cons S cs) :
  satisfied_cons S' cs := by
  -- proof idea: agree on all indices in support cs; hFresh ensures disjointness.
  -- use Stage1 `support_recordBoolean_mono` + â€œagree on supportâ€ helper.

lemma addConstraint_preserve_satisfied
  {S S' : System} {cs : List Constraint} {c : Constraint}
  (hStep : S' = S.addConstraint c)
  (hSat  : satisfied_cons S cs) :
  satisfied_cons S' cs := by
  -- constraints for `cs` unchanged; use Stage1 union lemma to localize.

lemma fresh_preserve_satisfied
  {S S' : System} {cs : List Constraint} {i : Var}
  (hFresh : Fresh S i)
  (hExtend : S' = S.extendFresh i) -- or your actual name
  (hSat : satisfied_cons S cs) :
  satisfied_cons S' cs := by
  -- same shape as recordBoolean, but for a generic â€œextendâ€
end BuilderPreserve
```

**Compile after each lemma** with the tree untouched.
**Commit:** â€œStage2: Prop-shaped preservation lemmas, no R1CSBool edits.â€

---

## Stage 3 â€” Local invariant shims (avoid the â€œunknown identifierâ€ errors)

**Goal:** decouple `R1CSBool` from a moving invariant API.

Add a tiny *adapter* module that only depends on fields you actually use:

```lean
-- Crypto/ZK/InvariantShim.lean
structure WeakInvariant (S : System) : Prop :=
  (agree_on_support :
     âˆ€ {S' cs}, support S'.constraints âŠ† support S.constraints â†’
       System.agreeOn (support cs) S.assignment S'.assignment)

namespace StrongInvariant
/-- Backfill for older files: provide `.toWeak` so code compiles. -/
def toWeak {S} (h : StrongInvariant S) : WeakInvariant S := {
  agree_on_support := by
    -- implement from StrongInvariantâ€™s fields if available,
    -- or provide the minimal lemma you need.
}
end StrongInvariant
```

Then, in places that referenced `StrongInvariant.toInvariant`, replace with `.toWeak`.
**Commit:** â€œStage3: invariant shim (`WeakInvariant`) with `StrongInvariant.toWeak`.â€

---

## Stage 4 â€” Refactor `applyAnd_strong` only

**Goal:** touch a single opcode, using the new wrappers + stable `satisfied_cons`.

Refactor outline:

```lean
-- Crypto/ZK/R1CSBool.lean
theorem applyAnd_strong
  (Hinv : StrongInvariant S)
  (hSat : System.satisfied_cons S cs)
  -- â€¦ your other preconditions â€¦
  : System.satisfied_cons S' cs := by
  -- 0) normalize shape
  simp [System.satisfied_iff_cons] at hSat âŠ¢

  -- 1) decompose the builder step into the small steps you actually perform
  --    (recordBoolean, addConstraint, fresh, etc.), each closed by Stage2 lemmas.
  have h1 : satisfied_cons Sâ‚ cs := BuilderPreserve.recordBoolean_preserve_satisfied ?fresh rfl hSat
  have h2 : satisfied_cons Sâ‚‚ cs := BuilderPreserve.addConstraint_preserve_satisfied rfl h1
  -- â€¦

  -- 2) where you need â€œagreement on old support,â€ call the shim:
  have W := (Hinv.toWeak).agree_on_support (by
    -- reuse Stage1 support lemmas to show subset)

  -- 3) finish with simp/finset ext; avoid expanding `satisfied`.
  simpa using hFinal
```

> **Donâ€™t** start `applyOr_strong` yet. Keep `Imp` untouched.

**Commit:** â€œStage4: refactor `applyAnd_strong` via preservation wrappers.â€

---

## Stage 5 â€” Add a scratch target & micro-tests

**Goal:** prevent another â€œballoon then sorryâ€ scenario.

Create **Crypto/ZK/Dev/Scratch.lean** with tiny unit tests:

```lean
example : System.satisfied_cons S cs â†” System.satisfied_cons S cs := by
  -- sanity via the shim
  simp [System.satisfied_iff_cons]

example (h : Fresh S i) :
  System.satisfied_cons (S.recordBoolean i true) cs
    := BuilderPreserve.recordBoolean_preserve_satisfied h rfl ?hSat
```

Wire a `lake exe zk-mini` (or a `#[test]` if you use a test harness) that only builds `Support`, `InvariantShim`, and `Scratch`.
**Commit:** â€œStage5: scratch target & micro tests (keeps compile times tiny).â€

---

## Stage 6 â€” Only then: `applyOr_strong`, then `applyImp_strong`

Repeat Stage 4 for `Or`, then for `Imp`.
If `Or` explodes in proof size, isolate the boolean closure lemma first (e.g., `bool_or_closure`), prove it in `Support.lean`, and use it as a single step inside the opcode proof.

**Commit(s):** â€œStage6A: refactor `applyOr_strong`,â€ then â€œStage6B: refactor `applyImp_strong`.â€

---

# Tactics & simp sets that will save you hours

* Put this at the top of the affected sections:

```lean
open Finset
attribute [simp] System.satisfied_iff_cons
```

* When you need set/finset equalities:

```lean
  ext v <;> by_cases hv : v âˆˆ support _ <;> simp [hv]
```

* For subset chains:

```lean
  refine subset_trans ?_ (by simp [Constraint.support_append])
```

* To stop unwanted unfolding:

```lean
  set_option tactic.hygienic true
  -- and prefer `simp [System.satisfied_iff_cons]` over `unfold`
```

* Use `simp_all` *late*, not earlyâ€”after youâ€™ve established the right shape via your Stage 0 lemma.

---

# How the lenses can help during each stage (optional but useful)

* **Graph lens**: query OpenHull of your goal to surface the *minimal* lemmas you need; keeps `applyAnd_strong` localized.
* **Tensor lens**: re-rank candidate helper lemmas by semantic proximity when the search space is noisy; the `Int` closure keeps the logic valid.
* **Topology lens**: if youâ€™re lost, raise the dial to zoom out and find a coarser explanation set, then refine back down.
* **Operator lens**: check for â€œnon-commuting tensionâ€ when two proof subpieces feel incompatibleâ€”if projection error is high, youâ€™re mixing incompatible invariants; split the step.

(If youâ€™ve wired the MCP tools from earlier, script your agent to call `lens.query{mode:"abduce", lens:"graph"}` before editing a proof, and `lens.verify` after each patch.)

---

# What to do right now (TL;DR checklist)

1. Fix the outstanding `simp`/`simpa` warnings and the unused `linhead_imp_support` parameter; rerun the warning-as-error build.
2. Finish Boolean R1CS soundness/completeness using the strengthened invariant and canonical trace.
3. Expose the proofs through the CLI executables and R1CS exporter.
