Multi-lens proof-carrying transactions (PCT) will sit on top of the nucleus-driven Heyting core and the transport infrastructure we already maintain under `lean/HeytingLean`. This document replaces the earlier adâ€‘hoc sketch with a Lean-first plan that matches the codebase, keeps proofs inside the existing build (`lake build -- -Dno_sorry -DwarningAsError=true`), and produces cryptographically consumable outputs (canonical traces and R1CS exports).

---

# 1â€¯â€¯Current Baseline

* **Core logic.** `HeytingLean/LoF` models the nucleus `R`, the fixed-point core `Î©_R`, and the stage semantics we already use for the bridge suite.
* **Lenses & transport.** `HeytingLean/Bridges` and `HeytingLean/Contracts` implement tensor, graph (Alexandroff), and Clifford lenses together with verified RT/TRI contracts. `HeytingLean/Runtime/BridgeSuite` exposes the multi-lens runtime entry point.
* **Proof widgets.** `HeytingLean/ProofWidgets` and the Law-of-Form blueprint give us graph visualisation, certified transports, and finite-model sanity checks.
* **Tooling.** `Docs/LoFBlueprint` (regenerated with `./tools/package_blueprint.sh`) tracks every Lean declaration; `lake build -- -Dno_sorry -DwarningAsError=true` is our CI target.

This plan assumes nothing beyond the current repo and keeps all new code under `lean/HeytingLean/Crypto` unless otherwise stated.

---

# 2â€¯â€¯Target Outcome

Verified-by-construction Multi-Lens ZK + Proof-Carrying Transactions with:

1. A shared **logical IR** interpreted in `Î©_R` and transported to every lens.
2. A **certified VM** + compiler per lens that preserve core semantics (RT/TRI aware).
3. A **witness relation** and proof objects whose soundness/completeness are proved in Lean.
4. A Boolean-lens lowering to **R1CS** plus JSON exporters so third-party provers can consume the circuit.
5. Executable entry points (`pct_prove`, `pct_verify`, `pct_r1cs`) generated by `lake exe` that inherit the theorems.

---

# Progress Snapshot

- âœ… Phaseâ€¯A â€“ Logical IR (`Crypto/Form`, `Crypto/CoreSemantics`).
- âœ… Phaseâ€¯B â€“ Lens abstraction & transport (`Crypto/Lens/*`).
- âœ… Phaseâ€¯C â€“ Postfix VM, compiler, and correctness (`Crypto/Prog`, `Crypto/VM`, `Crypto/Compile`, `Crypto/Correctness`).
- âœ… Phaseâ€¯D â€“ Witness relation & PCT payload (`Crypto/Witness`, `Crypto/PCT`).
- âœ… Phaseâ€¯E1 â€“ Boolean VM specialisation with canonical traces (`Crypto/BoolLens`).
- ğŸŸ¡ Phaseâ€¯E2 â€“ Boolean arithmetisation & R1CS scaffolding (`Crypto/ZK/BoolArith`, `Crypto/ZK/R1CS`, `Crypto/ZK/R1CSBool`).  
  _Next_: prove the generated constraints are sound/complete; compiler already emits witness variables matched to the canonical Boolean trace.
- â³ Phaseâ€¯E3 â€“ CLI executables and regression tests (not started).

Current focus: finish Phaseâ€¯E2 by proving the new R1CS constraints respect the Boolean semantics and expose the witness/output to downstream executables.

---

# 3â€¯â€¯Delivery Plan

## Phase A â€“ Logical IR and Core Semantics âœ…

- [x] `HeytingLean/Crypto/Form.lean` â€“ inductive IR over `Fin n` variables with Heyting connectives.
- [x] `HeytingLean/Crypto/CoreSemantics.lean` â€“ environment alias and `Form.evalÎ©` lemmas (`evalÎ©_and`, `evalÎ©_imp`, â€¦).

Deliverable status: âœ… `Form.evalÎ©` proved and in CI.

## Phase B â€“ Lens Semantics & Transport âœ…

- [x] `HeytingLean/Crypto/Lens/Class.lean` â€“ reusable `Lens` structure with lift helpers (`enc`, `dec`, `logicalShadow`, stack-friendly ops).
- [x] `HeytingLean/Crypto/Lens/Semantics.lean` â€“ lens-side environments and `Form.evalL`.
- [x] `HeytingLean/Crypto/Lens/Transport.lean` â€“ transport lemma `dec (evalL _ (enc âˆ˜ Ï)) = evalÎ© _ Ï`.

Deliverable status: âœ… transport soundness available for any `Lens`.

## Phase C â€“ Certified Program Representation âœ…

- [x] `HeytingLean/Crypto/Prog.lean` â€“ postfix instruction set (`Instr`, `Program`).
- [x] `HeytingLean/Crypto/VM.lean` â€“ stack machine with traces (`run`, `traceFrom`, lemmas like `exec_append`).
- [x] `HeytingLean/Crypto/Compile.lean` â€“ structural compiler and lemmas (`exec_compile_aux`, `run_compile_value`).
- [x] `HeytingLean/Crypto/Correctness.lean` â€“ canonical run/value helpers and theorem `compile_correct`.

Deliverable status: âœ… `compile_correct` ready for downstream lenses.

## Phase D â€“ Witness Relation & Proof-Carrying Transactions âœ…

- [x] `HeytingLean/Crypto/Witness.lean` â€“ canonical witness trace & relation, soundness/completeness lemmas.
- [x] `HeytingLean/Crypto/PCT.lean` â€“ payload structure, verification predicate, completeness witness.
- [ ] Executables (`Exec/pct_prove`, `Exec/pct_verify`) â€“ pending (see Phaseâ€¯E3).

Deliverable status: âœ… proof-carrying payload in Lean; CLI generation outstanding.

## Phase E â€“ Zero-Knowledge Lowering (Boolean Lens) â€“ In Progress

- âœ… **E1 â€“ Boolean VM specialisation (`HeytingLean/Crypto/BoolLens.lean`).**
  - Standalone Boolean evaluator (`eval`) and stack VM mirroring the generic pipeline.
  - Canonical `Trace`/`Value` helpers with lemma `canonicalValue_eq_eval`.
- ğŸŸ¡ **E2 â€“ R1CS backend.**
  - âœ… Boolean-to-field lemmas (`HeytingLean/Crypto/ZK/BoolArith`), minimal R1CS primitives (`HeytingLean/Crypto/ZK/R1CS`), and an initial compiler that emits constraints/witness (`HeytingLean/Crypto/ZK/R1CSBool`).
  - â³ Prove the generated R1CS instance is sound/complete w.r.t. `BoolLens` and surface the output/witness to the CLI layer.
- â³ **E3 â€“ Exporters.**
  - TODO: `Exec/pct_r1cs.lean`, JSON wiring, optional SNARK hand-off.

Deliverable: SNARK-friendly artefacts (pending).

## Phase F â€“ Testing & Tooling

1. **Deterministic finite models (`HeytingLean/Crypto/Models.lean`).**
   * Use the existing Alexandroff and tensor sample models for #eval regression tests.
2. **Test harness (`lean/Tests/CryptoSuite.lean`).**
   * Import all theorems, run sample forms through every lens.
3. **Blueprint updates.**
   * Document the new declarations in `Docs/LoFBlueprint` (the packaging script does the heavy lifting).
   * Add a short operatorâ€™s guide in `Docs/CryptoStack.md`.

Deliverable: a repeatable test suite invoked by `lake build` and CI.

---

# 4â€¯â€¯Build & Integration Checklist

1. **Lean build:** `cd lean && lake build -- -Dno_sorry -DwarningAsError=true`. âœ…
2. **Blueprint regeneration:** `cd blueprint && ./tools/package_blueprint.sh`.
3. **Executables:**
   * `lake exe pct_prove form.json env.json`. â³
   * `lake exe pct_verify form.json env.json trace.json`. â³
   * `lake exe pct_r1cs form.json env.json`. â³
4. **Optional SNARK test:** feed the generated `r1cs.json` + `assignment.json` into an external prover (outside the Lean repo).

---

# 5â€¯â€¯Success Criteria

- âœ… All new Lean files compile with zero `sorry` under the existing CI settings.
- âœ… `transport_sound` holds for every registered lens (tensor, graph, Clifford, Boolean via `BoolLens` semantics).
- âœ… VM correctness theorem (`compile_correct`) is in `HeytingLean.Crypto`.
- â³ PCT executables round-trip deterministic traces and align with the Lean proof.
- â³ Boolean lowering produces R1CS artefacts whose satisfaction proof is checked in Lean.

This plan keeps us aligned with the current codebase, leverages the bridge suite that already runs inside `lake env`, and yields cryptographically consumable artefacts backed by machine-checked proofs.

* `def compile : Form â†’ Prog` (postfix codegen).
* Lemma `compile_evalL`: `evalL L Ï† Ï = (run L (compile Ï†) Ï).snd`
  (induction on `Ï†`; VM aligns with evalL by construction).

**Cert/Correctness.lean**

* Combine `compile_evalL` with `transport_sound`:

```lean
theorem compile_correct (L) :
  âˆ€ Ï† Ï, L.dec (Prod.snd (run L (compile Ï†) (L.enc âˆ˜ Ï)))
      = evalÎ© Ï† Ï
```

This is the **central theorem** that makes the binaries proof-carrying by construction.

**Cert/Witness.lean**

* `def W_L (L) (Ï† Ï t) : Prop := t = (run L (compile Ï†) (L.enc âˆ˜ Ï)).fst`
* **Soundness:** `W_L L Ï† Ï t â†’ L.dec (out t) = evalÎ© Ï† Ï`
* **Completeness:** `âˆƒ t, W_L L Ï† Ï t`

---

## 4) Boolean-lens R1CS (ZK-ready)

Start with the **Bool lens** (`Int = id`, values in {0,1}), which arithmetizes cleanly.

**ZK/BoolArith.lean**

* Boolean constraints: `b*(b-1)=0`
* Gates:

  * `z_and = x*y`
  * `z_or  = x + y - x*y`
  * `z_not = 1 - x`
  * `z_impl = 1 - x + x*y`   -- (Â¬x âˆ¨ y)

**ZK/R1CS.lean**

* `structure R1CS := (A B C : List (LinComb)) ...`
* `def satisfies (assign : VarId â†’ F) : Prop := âˆ€ i, (Aáµ¢Â·a) * (Báµ¢Â·a) = (Cáµ¢Â·a)`

**ZK/R1CSBool.lean**

* Compile the canonical `BoolLens` trace to R1CS: allocate wires, enforce booleanity, and emit equality constraints for `push`, `and`, `or`, `imp`.
* Returns the generated system, witness assignment, and output wire (proofs pending).

**ZK/R1CSSoundness.lean** *(planned)*

* **Soundness:** if `assign` comes from `compile`, then `system.satisfied assignment` and the decoded output equals `evalÎ© Ï† Ï`.
* **Completeness:** given `Ï`, the canonical witness satisfies the R1CS.

**ZK/Export.lean** *(planned)*

* Serialize the R1CS system/witness (`r1cs.json`, `witness.json`) for external SNARK tooling.

---

## 5) Models & computations (finite demos)

**Models/Bool.lean**

* Instantiates `Lens` with `Carrier = Bool` âŠ† `{0,1}` and proves all lens laws.
* Exhaustive tables for 2â€“3 variables: check `compile_correct` by `#eval`.

**Models/FinGraph.lean**

* Finite preorder on `Fin n`; lens carrier = opens (down-sets); `Int = OpenHull`.
* Small enumerations to visualize `âˆ¨Ì‚` as open-hull of unions.

---

## 6) Tests & executables

**Tests/ProofSuite.lean (MUST pass with `-Dno_sorry`)**

* Imports everything; checks:

  * Heyting on `Î©_R`, residuation.
  * Transport soundness (generic).
  * `compile_correct` (generic).
  * R1CS soundness/completeness for Bool lens.

**Tests/FiniteCompute.lean**

* `#eval` tables for Bool and small graphs; print decoded equality checks.

**Exec/pct_prove.lean**

* Reads `env.json` + `Ï†.json`, runs `run L (compile Ï†) (enc âˆ˜ Ï)`, emits `trace.json` + `out.json`.

**Exec/pct_verify.lean**

* Replays trace; checks that `dec out = evalÎ© Ï† Ï`.
* Also option `--r1cs` to check `assignment.json` satisfies exported `r1cs.json`.

---

# ğŸ” â€œReal-world crypto readinessâ€ checklist

**Mathematical**

* [x] `compile_correct` proven (no `sorry`).
* [x] Witness soundness/completeness proven.
* [ ] Boolean lens R1CS soundness/completeness proven.

**Engineering (deterministic & safe)**

* [ ] Executables compiled from the same Lean sources (so the VM *is* the proved function).
* [ ] Inputs validated (booleans/ranges; no NaNs).
* [ ] Transcript format stable (hash over `(spec_commit, lens_id, prog, env, trace, out)`).

**Interoperability**

* [ ] `r1cs.json` schema compatible with standard provers (arkworks/bellman/circom-like field & wiring).
* [ ] `witness.json` uses the same wire order as `r1cs.json`.

**Security**

* [ ] For Bool lens: all wires constrained boolean.
* [ ] For other lenses: (deferred) introduce range proofs or discretizations before arithmetization.

---

## ğŸ§© Minimal agent TODOs (copy-paste tasks)

- [x] Create modules exactly as listed; wire `lake build -- -Dno_sorry -DwarningAsError=true`.
- [x] Implement Boolean VM specialisation (`Crypto/BoolLens`) and canonical traces.
- [x] Implement `compile`, `VM.run`, and prove `compile_correct`.
- [x] Prove transport soundness once; derive `compile_correct`.
- [x] Define `Witness`/`PCT` and prove sound/complete.
- [x] Implement Boolean arithmetisation primitives and initial R1CS compiler (`Crypto/ZK/BoolArith`, `Crypto/ZK/R1CS`, `Crypto/ZK/R1CSBool`).
- [ ] Compile canonical Boolean traces to R1CS + witness; prove soundness/completeness.
- [ ] Add executables (`pct_prove`, `pct_verify`, `pct_r1cs`) and regression demos.

When those 7 are green, you have **verified-by-construction Multi-Lens ZK + PCT** with a **cryptographically consumable** output formatâ€”and you can add more lenses or richer arithmetization with confidence later.
