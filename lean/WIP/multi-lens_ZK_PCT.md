Multi-lens proof-carrying transactions (ML-PCT) will sit on top of the nucleus-driven Heyting core and the transport infrastructure we already maintain under `lean/HeytingLean`. This document replaces the earlier ad‑hoc sketch with a Lean-first plan that matches the codebase, keeps proofs inside the existing build (`lake build -- -Dno_sorry -DwarningAsError=true`), and produces cryptographically consumable outputs (canonical traces and R1CS exports).

---

# 1  Current Baseline

* **Core logic.** `HeytingLean/LoF` models the nucleus `R`, the fixed-point core `Ω_R`, and the stage semantics we already use for the bridge suite.
* **Lenses & transport.** `HeytingLean/Bridges` and `HeytingLean/Contracts` implement tensor, graph (Alexandroff), and Clifford lenses together with verified RT/TRI contracts. `HeytingLean/Runtime/BridgeSuite` exposes the multi-lens runtime entry point.
* **Proof widgets.** `HeytingLean/ProofWidgets` and the Law-of-Form blueprint give us graph visualisation, certified transports, and finite-model sanity checks.
* **Tooling.** `Docs/LoFBlueprint` (regenerated with `./tools/package_blueprint.sh`) tracks every Lean declaration; `lake build -- -Dno_sorry -DwarningAsError=true` is our CI target.

This plan assumes nothing beyond the current repo and keeps all new code under `lean/HeytingLean/Crypto` unless otherwise stated.

---

# 2  Target Outcome

Verified-by-construction Multi-Lens ZK + Proof-Carrying Transactions with:

1. A shared **logical IR** interpreted in `Ω_R` and transported to every lens.
2. A **certified VM** + compiler per lens that preserve core semantics (RT/TRI aware).
3. A **witness relation** and proof objects whose soundness/completeness are proved in Lean.
4. A Boolean-lens lowering to **R1CS** plus JSON exporters so third-party provers can consume the circuit.
5. Executable entry points (`pct_prove`, `pct_verify`, `pct_r1cs`) generated by `lake exe` that inherit the theorems.

---

# Progress Snapshot

- ✅ Phase A – Logical IR (`Crypto/Form`, `Crypto/CoreSemantics`).
- ✅ Phase B – Lens abstraction & transport (`Crypto/Lens/*`).
- ✅ Phase C – Postfix VM, compiler, and correctness (`Crypto/Prog`, `Crypto/VM`, `Crypto/Compile`, `Crypto/Correctness`).
- ✅ Phase D – Witness relation & PCT payload (`Crypto/Witness`, `Crypto/PCT`).
- ✅ Phase E1 – Boolean VM specialisation with canonical traces (`Crypto/BoolLens`).
- 🟡 Phase E2 – Boolean arithmetisation & R1CS scaffolding (`Crypto/ZK/BoolArith`, `Crypto/ZK/R1CS`, `Crypto/ZK/R1CSBool`).  
  _Current status:_  
  • Canonical BoolLens trace/value available (`Crypto/BoolLens`).  
  • Support-oriented utilities factored out (`Crypto/ZK/Support`) giving `AgreesOn`, `support`, and `System.satisfied_ext` lemmas (ready for use).  
  • Boolean builder still uses the original lightweight invariant (`Matches`/`Bounded`); support/satisfaction strengthening staged to land next.  
  • R1CS compiler emits witness/constraints for all opcodes (no global proof yet).  
  _Next steps:_  
  1. Introduce a strengthened `StrongInvariant` (tracks `SupportOK`/`Satisfied`) alongside the existing invariant and prove a dedicated `pushConst_strong`.  
  2. Bridge `StrongInvariant` back to the old invariant (`Invariant_of_strong` helper) so existing lemmas continue to compile while we migrate.  
  3. Reprove opcode preservation (`applyAnd`/`applyOr`/`applyImp`) under the strong invariant using the new support lemmas.  
  4. Induct over `compileSteps` with the strong invariant to show the final builder satisfies support/satisfaction obligations.  
  5. Establish `soundness`: compiled `(system, assignment)` satisfies every constraint and output matches `BoolLens.eval`.  
  6. Establish `completeness`: canonical trace provides a satisfying assignment.  
  7. Expose the Boolean witness/output to the CLI layer once proofs land.
- ⏳ Phase E3 – CLI executables and regression tests (not started).

Current focus: carry the Boolean stack invariant through `applyAnd`/`applyOr`/`applyImp`, then lift it to `compileSteps` to obtain full R1CS soundness/completeness before wiring the witness into the CLI.

---

# 3  Delivery Plan

## Phase A – Logical IR and Core Semantics ✅

- [x] `HeytingLean/Crypto/Form.lean` – inductive IR over `Fin n` variables with Heyting connectives.
- [x] `HeytingLean/Crypto/CoreSemantics.lean` – environment alias and `Form.evalΩ` lemmas (`evalΩ_and`, `evalΩ_imp`, …).

Deliverable status: ✅ `Form.evalΩ` proved and in CI.

## Phase B – Lens Semantics & Transport ✅

- [x] `HeytingLean/Crypto/Lens/Class.lean` – reusable `Lens` structure with lift helpers (`enc`, `dec`, `logicalShadow`, stack-friendly ops).
- [x] `HeytingLean/Crypto/Lens/Semantics.lean` – lens-side environments and `Form.evalL`.
- [x] `HeytingLean/Crypto/Lens/Transport.lean` – transport lemma `dec (evalL _ (enc ∘ ρ)) = evalΩ _ ρ`.

Deliverable status: ✅ transport soundness available for any `Lens`.

## Phase C – Certified Program Representation ✅

- [x] `HeytingLean/Crypto/Prog.lean` – postfix instruction set (`Instr`, `Program`).
- [x] `HeytingLean/Crypto/VM.lean` – stack machine with traces (`run`, `traceFrom`, lemmas like `exec_append`).
- [x] `HeytingLean/Crypto/Compile.lean` – structural compiler and lemmas (`exec_compile_aux`, `run_compile_value`).
- [x] `HeytingLean/Crypto/Correctness.lean` – canonical run/value helpers and theorem `compile_correct`.

Deliverable status: ✅ `compile_correct` ready for downstream lenses.

## Phase D – Witness Relation & Proof-Carrying Transactions ✅

- [x] `HeytingLean/Crypto/Witness.lean` – canonical witness trace & relation, soundness/completeness lemmas.
- [x] `HeytingLean/Crypto/PCT.lean` – payload structure, verification predicate, completeness witness.
- [ ] Executables (`Exec/pct_prove`, `Exec/pct_verify`) – pending (see Phase E3).

Deliverable status: ✅ proof-carrying payload in Lean; CLI generation outstanding.

## Phase E – Zero-Knowledge Lowering (Boolean Lens) – In Progress

- ✅ **E1 – Boolean VM specialisation (`HeytingLean/Crypto/BoolLens.lean`).**
  - Standalone Boolean evaluator (`eval`) and stack VM mirroring the generic pipeline.
  - Canonical `Trace`/`Value` helpers with lemma `canonicalValue_eq_eval`.
- 🟡 **E2 – R1CS backend.**
- ✅ Boolean-to-field lemmas (`HeytingLean/Crypto/ZK/BoolArith`), minimal R1CS primitives (`HeytingLean/Crypto/ZK/R1CS`), and an initial compiler plus stack invariants (`HeytingLean/Crypto/ZK/R1CSBool` – `pushConst` case proven).
- ⏳ Extend invariants to `applyAnd`/`applyOr`/`applyImp`, then prove the generated R1CS instance is sound/complete w.r.t. `BoolLens`, surfacing the witness/output to the CLI layer.
- ⏳ **E3 – Exporters.**
  - TODO: `Exec/pct_r1cs.lean`, JSON wiring, optional SNARK hand-off.

Deliverable: SNARK-friendly artefacts (pending).

## Phase F – Testing & Tooling

1. **Deterministic finite models (`HeytingLean/Crypto/Models.lean`).**
   * Use the existing Alexandroff and tensor sample models for #eval regression tests.
2. **Test harness (`lean/Tests/CryptoSuite.lean`).**
   * Import all theorems, run sample forms through every lens.
3. **Blueprint updates.**
   * Document the new declarations in `Docs/LoFBlueprint` (the packaging script does the heavy lifting).
   * Add a short operator’s guide in `Docs/CryptoStack.md`.

Deliverable: a repeatable test suite invoked by `lake build` and CI.

---

# 4  Build & Integration Checklist

1. **Lean build:** `cd lean && lake build -- -Dno_sorry -DwarningAsError=true`. ✅
2. **Blueprint regeneration:** `cd blueprint && ./tools/package_blueprint.sh`.
3. **Executables:**
   * `lake exe pct_prove form.json env.json`. ⏳
   * `lake exe pct_verify form.json env.json trace.json`. ⏳
   * `lake exe pct_r1cs form.json env.json`. ⏳
4. **Optional SNARK test:** feed the generated `r1cs.json` + `assignment.json` into an external prover (outside the Lean repo).

---

# 5  Success Criteria

- ✅ All new Lean files compile with zero `sorry` under the existing CI settings.
- ✅ `transport_sound` holds for every registered lens (tensor, graph, Clifford, Boolean via `BoolLens` semantics).
- ✅ VM correctness theorem (`compile_correct`) is in `HeytingLean.Crypto`.
- ⏳ PCT executables round-trip deterministic traces and align with the Lean proof.
- ⏳ Boolean lowering produces R1CS artefacts whose satisfaction proof is checked in Lean.

This plan keeps us aligned with the current codebase, leverages the bridge suite that already runs inside `lake env`, and yields cryptographically consumable artefacts backed by machine-checked proofs.

* `def compile : Form → Prog` (postfix codegen).
* Lemma `compile_evalL`: `evalL L φ ρ = (run L (compile φ) ρ).snd`
  (induction on `φ`; VM aligns with evalL by construction).

**Cert/Correctness.lean**

* Combine `compile_evalL` with `transport_sound`:

```lean
theorem compile_correct (L) :
  ∀ φ ρ, L.dec (Prod.snd (run L (compile φ) (L.enc ∘ ρ)))
      = evalΩ φ ρ
```

This is the **central theorem** that makes the binaries proof-carrying by construction.

**Cert/Witness.lean**

* `def W_L (L) (φ ρ t) : Prop := t = (run L (compile φ) (L.enc ∘ ρ)).fst`
* **Soundness:** `W_L L φ ρ t → L.dec (out t) = evalΩ φ ρ`
* **Completeness:** `∃ t, W_L L φ ρ t`

---

## 4) Boolean-lens R1CS (ZK-ready)

Start with the **Bool lens** (`Int = id`, values in {0,1}), which arithmetizes cleanly.

**ZK/BoolArith.lean**

* Boolean constraints: `b*(b-1)=0`
* Gates:

  * `z_and = x*y`
  * `z_or  = x + y - x*y`
  * `z_not = 1 - x`
  * `z_impl = 1 - x + x*y`   -- (¬x ∨ y)

**ZK/R1CS.lean**

* `structure R1CS := (A B C : List (LinComb)) ...`
* `def satisfies (assign : VarId → F) : Prop := ∀ i, (Aᵢ·a) * (Bᵢ·a) = (Cᵢ·a)`

**ZK/R1CSBool.lean**

* Compile the canonical `BoolLens` trace to R1CS: allocate wires, enforce booleanity, and emit equality constraints for `push`, `and`, `or`, `imp`.
* Invariants (`Matches`, `Bounded`, `Invariant`) established; `pushConst` case proved. Pending: extend invariant proofs to `applyAnd`/`applyOr`/`applyImp`, then lift to `compileSteps` for global soundness/completeness.

**ZK/R1CSSoundness.lean** *(planned)*

* **Soundness:** if `assign` comes from `compile`, then `system.satisfied assignment` and the decoded output equals `evalΩ φ ρ`.
* **Completeness:** given `ρ`, the canonical witness satisfies the R1CS.

**ZK/Export.lean** *(planned)*

* Serialize the R1CS system/witness (`r1cs.json`, `witness.json`) for external SNARK tooling.

### E2 invariant → compiled R1CS pipeline (ordered worklist)

1. **Finalize invariant primitives (in progress):**
   - Landed `Builder.system`, `SupportOK`, and the bundled `StrongInvariant` (with projector lemmas and `StrongInvariant.toInvariant`) in `R1CSBool.lean`.
   - Added the initial builder simp facts (`system_fresh`, `system_addConstraint`, `system_recordBoolean`) plus the fresh-variable helpers (`fresh_preserve_support`, `fresh_agreesOn_range`, `fresh_preserve_satisfied`).
   - ✅ Next up: push the support/satisfaction plumbing through `addConstraint`/`recordBoolean`, extend the linear-combination support/satisfaction lemmas, and reprove `pushConst` under the strong invariant.
2. **Binary opcode preservation lemmas:**
   - Reprove `applyAnd`/`applyOr`/`applyImp` preservation with the strengthened primitive lemmas; keep the original invariant lemmas as corollaries until all call sites switch over.
3. **`compileStep` wrapper:**
   - Define `compileStep_preserves_strong` dispatching to the strong push/AND/OR/IMP lemmas; derive the existing lemma from it.
   - Provide a trivial “invalid trace” branch that returns the invariant unchanged.
4. **`compileSteps` induction:**
   - Prove `compileSteps_preserves_strong` by induction, threading `traceFrom` and the strong invariant.
   - Specialise to the lightweight invariant for backwards compatibility.
5. **Constraint satisfaction + witness extraction:**
   - Use the strong invariant to show `builder.constraints` are satisfied (`compiled_satisfies`) and that booleanity holds for every allocated wire.
   - Ensure the output alignment lemma (`compiled_output_matches`) continues to use `Matches.length_eq` and VM correctness.
6. **Soundness/completeness statements (`ZK/R1CSSoundness.lean`):**
   - Package the above into `compiled_sound` and `compiled_complete`, relating the builder witness to the canonical trace from `BoolLens`.
   - Bridge these results to the existing `Witness`/`PCT` layer so the CLI can reuse the Lean proofs.
7. **Refactor `compileStep` implementation if necessary:** ensure the Lean code matches the proof structure (e.g., reuse helper functions for readability once all lemmas exist).

### Soundness/completeness integration checklist

1. **Constraint satisfaction proof:** utilise `compiled_satisfies` to show `System.satisfied compiled.assignment compiled.system`.
2. **Output alignment:** combine `compiled_output_matches` with `BoolLens.exec_compile_aux` to rewrite the decoded result to `BoolLens.eval`.
3. **Theorems:** record the final `compiled_sound` / `compiled_complete` statements for re-use across the CLI and regression tests.
4. **Witness bridge:** map the compiled assignment into the existing PCT witness relation so verification can operate on a single canonical format.

### Phase E3 wiring notes

- **Executable plumbing:** after soundness/completeness, add `lake exe pct_r1cs` that runs `compile`, writes `r1cs.json`/`assignment.json`, and (optionally) hashes the trace metadata alongside `pct_prove`/`pct_verify`.
- **JSON schema:** reuse the existing codec helpers in `Contracts` for `Form`, `Env`, and extend them with simple encoders for `LinComb` (`const`, `terms`) and constraints (`A`, `B`, `C`) so downstream SNARK tooling can parse the artefacts.
- **Regression hooks:** add `Tests/CryptoSuite.lean` cases that call the new theorems on sample formulas; for CLI smoke tests, shell out to `lake exe pct_r1cs` with a two-variable example and check the emitted assignment matches `BoolLens.eval`.

---

## 5) Models & computations (finite demos)

**Models/Bool.lean**

* Instantiates `Lens` with `Carrier = Bool` ⊆ `{0,1}` and proves all lens laws.
* Exhaustive tables for 2–3 variables: check `compile_correct` by `#eval`.

**Models/FinGraph.lean**

* Finite preorder on `Fin n`; lens carrier = opens (down-sets); `Int = OpenHull`.
* Small enumerations to visualize `∨̂` as open-hull of unions.

---

## 6) Tests & executables

**Tests/ProofSuite.lean (MUST pass with `-Dno_sorry`)**

* Imports everything; checks:

  * Heyting on `Ω_R`, residuation.
  * Transport soundness (generic).
  * `compile_correct` (generic).
  * R1CS soundness/completeness for Bool lens.

**Tests/FiniteCompute.lean**

* `#eval` tables for Bool and small graphs; print decoded equality checks.

**Exec/pct_prove.lean**

* Reads `env.json` + `φ.json`, runs `run L (compile φ) (enc ∘ ρ)`, emits `trace.json` + `out.json`.

**Exec/pct_verify.lean**

* Replays trace; checks that `dec out = evalΩ φ ρ`.
* Also option `--r1cs` to check `assignment.json` satisfies exported `r1cs.json`.

---

# 🔐 “Real-world crypto readiness” checklist

**Mathematical**

* [x] `compile_correct` proven (no `sorry`).
* [x] Witness soundness/completeness proven.
* [ ] Boolean lens R1CS soundness/completeness proven.

**Engineering (deterministic & safe)**

* [ ] Executables compiled from the same Lean sources (so the VM *is* the proved function).
* [ ] Inputs validated (booleans/ranges; no NaNs).
* [ ] Transcript format stable (hash over `(spec_commit, lens_id, prog, env, trace, out)`).

**Interoperability**

* [ ] `r1cs.json` schema compatible with standard provers (arkworks/bellman/circom-like field & wiring).
* [ ] `witness.json` uses the same wire order as `r1cs.json`.

**Security**

* [ ] For Bool lens: all wires constrained boolean.
* [ ] For other lenses: (deferred) introduce range proofs or discretizations before arithmetization.

---

## 🧩 Minimal agent TODOs (copy-paste tasks)

- [x] Create modules exactly as listed; wire `lake build -- -Dno_sorry -DwarningAsError=true`.
- [x] Implement Boolean VM specialisation (`Crypto/BoolLens`) and canonical traces.
- [x] Implement `compile`, `VM.run`, and prove `compile_correct`.
- [x] Prove transport soundness once; derive `compile_correct`.
- [ ] Extend the Boolean invariants:
    0. Strengthen `Crypto/ZK/Support.lean` with the helper lemmas we actually need: `LinComb.support_single`, `LinComb.support_ofConst`, `LinComb.eval_single`, `LinComb.eval_ofConst`, and the constraint-specific support/satisfaction facts for `boolConstraint`/`eqConstConstraint`.
    1. Use those helpers to extend `Crypto/ZK/R1CSBool.lean`: add the `SupportOK`/`satisfied` preservation lemmas for `fresh`, `addConstraint`, and `recordBoolean` (relying on `Builder.system_addConstraint`/`Builder.system_recordBoolean` rather than raw list manipulations).
    2. Package the subset facts (`range_subset_succ`, `singleton_subset_range`, `AgreesOn.mono`) so `StrongInvariant` proofs can just `simp`/`subset_trans`.
    3. Reprove `pushConst` against `StrongInvariant`, keeping the booleanity proof isolated in the head lemmas.
    4. Show the existing invariant is a projection of `StrongInvariant` (`toInvariant` lemma).
    5. Prove `applyAnd`, `applyOr`, and `applyImp` preserve `StrongInvariant` without reintroducing duplication or `System.satisfied_ext`.
    6. Induct over `compileSteps` with the strong invariant to obtain full soundness/completeness for the generated R1CS, exposing witness/output to the CLI layer.
- [ ] Add executables (`pct_prove`, `pct_verify`, `pct_r1cs`) and regression demos.

When those 7 are green, you have **verified-by-construction Multi-Lens ZK + PCT** with a **cryptographically consumable** output format—and you can add more lenses or richer arithmetization with confidence later.
