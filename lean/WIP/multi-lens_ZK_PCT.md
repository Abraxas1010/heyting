Multi-lens proof-carrying transactions (PCT) will sit on top of the nucleus-driven Heyting core and the transport infrastructure we already maintain under `lean/HeytingLean`. This document replaces the earlier ad‑hoc sketch with a Lean-first plan that matches the codebase, keeps proofs inside the existing build (`lake build -- -Dno_sorry -DwarningAsError=true`), and produces cryptographically consumable outputs (canonical traces and R1CS exports).

---

# 1  Current Baseline

* **Core logic.** `HeytingLean/LoF` models the nucleus `R`, the fixed-point core `Ω_R`, and the stage semantics we already use for the bridge suite.
* **Lenses & transport.** `HeytingLean/Bridges` and `HeytingLean/Contracts` implement tensor, graph (Alexandroff), and Clifford lenses together with verified RT/TRI contracts. `HeytingLean/Runtime/BridgeSuite` exposes the multi-lens runtime entry point.
* **Proof widgets.** `HeytingLean/ProofWidgets` and the Law-of-Form blueprint give us graph visualisation, certified transports, and finite-model sanity checks.
* **Tooling.** `Docs/LoFBlueprint` (regenerated with `./tools/package_blueprint.sh`) tracks every Lean declaration; `lake build -- -Dno_sorry -DwarningAsError=true` is our CI target.

This plan assumes nothing beyond the current repo and keeps all new code under `lean/HeytingLean/Crypto` unless otherwise stated.

---

# 2  Target Outcome

Verified-by-construction Multi-Lens ZK + Proof-Carrying Transactions with:

1. A shared **logical IR** interpreted in `Ω_R` and transported to every lens.
2. A **certified VM** + compiler per lens that preserve core semantics (RT/TRI aware).
3. A **witness relation** and proof objects whose soundness/completeness are proved in Lean.
4. A Boolean-lens lowering to **R1CS** plus JSON exporters so third-party provers can consume the circuit.
5. Executable entry points (`pct_prove`, `pct_verify`, `pct_r1cs`) generated by `lake exe` that inherit the theorems.

---

# Progress Snapshot

- ✅ Phase A – Logical IR (`Crypto/Form`, `Crypto/CoreSemantics`).
- ✅ Phase B – Lens abstraction & transport (`Crypto/Lens/*`).
- ✅ Phase C – Postfix VM, compiler, and correctness (`Crypto/Prog`, `Crypto/VM`, `Crypto/Compile`, `Crypto/Correctness`).
- ✅ Phase D – Witness relation & PCT payload (`Crypto/Witness`, `Crypto/PCT`).
- ✅ Phase E1 – Boolean VM specialisation with canonical traces (`Crypto/BoolLens`).
- 🟡 Phase E2 – Boolean arithmetisation & R1CS scaffolding (`Crypto/ZK/BoolArith`, `Crypto/ZK/R1CS`, `Crypto/ZK/R1CSBool`).  
  _Next_: prove the generated constraints are sound/complete; compiler already emits witness variables matched to the canonical Boolean trace.
- ⏳ Phase E3 – CLI executables and regression tests (not started).

Current focus: finish Phase E2 by proving the new R1CS constraints respect the Boolean semantics and expose the witness/output to downstream executables.

---

# 3  Delivery Plan

## Phase A – Logical IR and Core Semantics ✅

- [x] `HeytingLean/Crypto/Form.lean` – inductive IR over `Fin n` variables with Heyting connectives.
- [x] `HeytingLean/Crypto/CoreSemantics.lean` – environment alias and `Form.evalΩ` lemmas (`evalΩ_and`, `evalΩ_imp`, …).

Deliverable status: ✅ `Form.evalΩ` proved and in CI.

## Phase B – Lens Semantics & Transport ✅

- [x] `HeytingLean/Crypto/Lens/Class.lean` – reusable `Lens` structure with lift helpers (`enc`, `dec`, `logicalShadow`, stack-friendly ops).
- [x] `HeytingLean/Crypto/Lens/Semantics.lean` – lens-side environments and `Form.evalL`.
- [x] `HeytingLean/Crypto/Lens/Transport.lean` – transport lemma `dec (evalL _ (enc ∘ ρ)) = evalΩ _ ρ`.

Deliverable status: ✅ transport soundness available for any `Lens`.

## Phase C – Certified Program Representation ✅

- [x] `HeytingLean/Crypto/Prog.lean` – postfix instruction set (`Instr`, `Program`).
- [x] `HeytingLean/Crypto/VM.lean` – stack machine with traces (`run`, `traceFrom`, lemmas like `exec_append`).
- [x] `HeytingLean/Crypto/Compile.lean` – structural compiler and lemmas (`exec_compile_aux`, `run_compile_value`).
- [x] `HeytingLean/Crypto/Correctness.lean` – canonical run/value helpers and theorem `compile_correct`.

Deliverable status: ✅ `compile_correct` ready for downstream lenses.

## Phase D – Witness Relation & Proof-Carrying Transactions ✅

- [x] `HeytingLean/Crypto/Witness.lean` – canonical witness trace & relation, soundness/completeness lemmas.
- [x] `HeytingLean/Crypto/PCT.lean` – payload structure, verification predicate, completeness witness.
- [ ] Executables (`Exec/pct_prove`, `Exec/pct_verify`) – pending (see Phase E3).

Deliverable status: ✅ proof-carrying payload in Lean; CLI generation outstanding.

## Phase E – Zero-Knowledge Lowering (Boolean Lens) – In Progress

- ✅ **E1 – Boolean VM specialisation (`HeytingLean/Crypto/BoolLens.lean`).**
  - Standalone Boolean evaluator (`eval`) and stack VM mirroring the generic pipeline.
  - Canonical `Trace`/`Value` helpers with lemma `canonicalValue_eq_eval`.
- 🟡 **E2 – R1CS backend.**
  - ✅ Boolean-to-field lemmas (`HeytingLean/Crypto/ZK/BoolArith`), minimal R1CS primitives (`HeytingLean/Crypto/ZK/R1CS`), and an initial compiler that emits constraints/witness (`HeytingLean/Crypto/ZK/R1CSBool`).
  - ⏳ Prove the generated R1CS instance is sound/complete w.r.t. `BoolLens` and surface the output/witness to the CLI layer.
- ⏳ **E3 – Exporters.**
  - TODO: `Exec/pct_r1cs.lean`, JSON wiring, optional SNARK hand-off.

Deliverable: SNARK-friendly artefacts (pending).

## Phase F – Testing & Tooling

1. **Deterministic finite models (`HeytingLean/Crypto/Models.lean`).**
   * Use the existing Alexandroff and tensor sample models for #eval regression tests.
2. **Test harness (`lean/Tests/CryptoSuite.lean`).**
   * Import all theorems, run sample forms through every lens.
3. **Blueprint updates.**
   * Document the new declarations in `Docs/LoFBlueprint` (the packaging script does the heavy lifting).
   * Add a short operator’s guide in `Docs/CryptoStack.md`.

Deliverable: a repeatable test suite invoked by `lake build` and CI.

---

# 4  Build & Integration Checklist

1. **Lean build:** `cd lean && lake build -- -Dno_sorry -DwarningAsError=true`. ✅
2. **Blueprint regeneration:** `cd blueprint && ./tools/package_blueprint.sh`.
3. **Executables:**
   * `lake exe pct_prove form.json env.json`. ⏳
   * `lake exe pct_verify form.json env.json trace.json`. ⏳
   * `lake exe pct_r1cs form.json env.json`. ⏳
4. **Optional SNARK test:** feed the generated `r1cs.json` + `assignment.json` into an external prover (outside the Lean repo).

---

# 5  Success Criteria

- ✅ All new Lean files compile with zero `sorry` under the existing CI settings.
- ✅ `transport_sound` holds for every registered lens (tensor, graph, Clifford, Boolean via `BoolLens` semantics).
- ✅ VM correctness theorem (`compile_correct`) is in `HeytingLean.Crypto`.
- ⏳ PCT executables round-trip deterministic traces and align with the Lean proof.
- ⏳ Boolean lowering produces R1CS artefacts whose satisfaction proof is checked in Lean.

This plan keeps us aligned with the current codebase, leverages the bridge suite that already runs inside `lake env`, and yields cryptographically consumable artefacts backed by machine-checked proofs.

* `def compile : Form → Prog` (postfix codegen).
* Lemma `compile_evalL`: `evalL L φ ρ = (run L (compile φ) ρ).snd`
  (induction on `φ`; VM aligns with evalL by construction).

**Cert/Correctness.lean**

* Combine `compile_evalL` with `transport_sound`:

```lean
theorem compile_correct (L) :
  ∀ φ ρ, L.dec (Prod.snd (run L (compile φ) (L.enc ∘ ρ)))
      = evalΩ φ ρ
```

This is the **central theorem** that makes the binaries proof-carrying by construction.

**Cert/Witness.lean**

* `def W_L (L) (φ ρ t) : Prop := t = (run L (compile φ) (L.enc ∘ ρ)).fst`
* **Soundness:** `W_L L φ ρ t → L.dec (out t) = evalΩ φ ρ`
* **Completeness:** `∃ t, W_L L φ ρ t`

---

## 4) Boolean-lens R1CS (ZK-ready)

Start with the **Bool lens** (`Int = id`, values in {0,1}), which arithmetizes cleanly.

**ZK/BoolArith.lean**

* Boolean constraints: `b*(b-1)=0`
* Gates:

  * `z_and = x*y`
  * `z_or  = x + y - x*y`
  * `z_not = 1 - x`
  * `z_impl = 1 - x + x*y`   -- (¬x ∨ y)

**ZK/R1CS.lean**

* `structure R1CS := (A B C : List (LinComb)) ...`
* `def satisfies (assign : VarId → F) : Prop := ∀ i, (Aᵢ·a) * (Bᵢ·a) = (Cᵢ·a)`

**ZK/R1CSBool.lean**

* Compile the canonical `BoolLens` trace to R1CS: allocate wires, enforce booleanity, and emit equality constraints for `push`, `and`, `or`, `imp`.
* Returns the generated system, witness assignment, and output wire (proofs pending).

**ZK/R1CSSoundness.lean** *(planned)*

* **Soundness:** if `assign` comes from `compile`, then `system.satisfied assignment` and the decoded output equals `evalΩ φ ρ`.
* **Completeness:** given `ρ`, the canonical witness satisfies the R1CS.

**ZK/Export.lean** *(planned)*

* Serialize the R1CS system/witness (`r1cs.json`, `witness.json`) for external SNARK tooling.

---

## 5) Models & computations (finite demos)

**Models/Bool.lean**

* Instantiates `Lens` with `Carrier = Bool` ⊆ `{0,1}` and proves all lens laws.
* Exhaustive tables for 2–3 variables: check `compile_correct` by `#eval`.

**Models/FinGraph.lean**

* Finite preorder on `Fin n`; lens carrier = opens (down-sets); `Int = OpenHull`.
* Small enumerations to visualize `∨̂` as open-hull of unions.

---

## 6) Tests & executables

**Tests/ProofSuite.lean (MUST pass with `-Dno_sorry`)**

* Imports everything; checks:

  * Heyting on `Ω_R`, residuation.
  * Transport soundness (generic).
  * `compile_correct` (generic).
  * R1CS soundness/completeness for Bool lens.

**Tests/FiniteCompute.lean**

* `#eval` tables for Bool and small graphs; print decoded equality checks.

**Exec/pct_prove.lean**

* Reads `env.json` + `φ.json`, runs `run L (compile φ) (enc ∘ ρ)`, emits `trace.json` + `out.json`.

**Exec/pct_verify.lean**

* Replays trace; checks that `dec out = evalΩ φ ρ`.
* Also option `--r1cs` to check `assignment.json` satisfies exported `r1cs.json`.

---

# 🔐 “Real-world crypto readiness” checklist

**Mathematical**

* [x] `compile_correct` proven (no `sorry`).
* [x] Witness soundness/completeness proven.
* [ ] Boolean lens R1CS soundness/completeness proven.

**Engineering (deterministic & safe)**

* [ ] Executables compiled from the same Lean sources (so the VM *is* the proved function).
* [ ] Inputs validated (booleans/ranges; no NaNs).
* [ ] Transcript format stable (hash over `(spec_commit, lens_id, prog, env, trace, out)`).

**Interoperability**

* [ ] `r1cs.json` schema compatible with standard provers (arkworks/bellman/circom-like field & wiring).
* [ ] `witness.json` uses the same wire order as `r1cs.json`.

**Security**

* [ ] For Bool lens: all wires constrained boolean.
* [ ] For other lenses: (deferred) introduce range proofs or discretizations before arithmetization.

---

## 🧩 Minimal agent TODOs (copy-paste tasks)

- [x] Create modules exactly as listed; wire `lake build -- -Dno_sorry -DwarningAsError=true`.
- [x] Implement Boolean VM specialisation (`Crypto/BoolLens`) and canonical traces.
- [x] Implement `compile`, `VM.run`, and prove `compile_correct`.
- [x] Prove transport soundness once; derive `compile_correct`.
- [x] Define `Witness`/`PCT` and prove sound/complete.
- [x] Implement Boolean arithmetisation primitives and initial R1CS compiler (`Crypto/ZK/BoolArith`, `Crypto/ZK/R1CS`, `Crypto/ZK/R1CSBool`).
- [ ] Compile canonical Boolean traces to R1CS + witness; prove soundness/completeness.
- [ ] Add executables (`pct_prove`, `pct_verify`, `pct_r1cs`) and regression demos.

When those 7 are green, you have **verified-by-construction Multi-Lens ZK + PCT** with a **cryptographically consumable** output format—and you can add more lenses or richer arithmetization with confidence later.
